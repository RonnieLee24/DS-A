# 面试突击

# Spring

## 1. 配置文件

1. Spring配置文件：beans.xml 放在 src 目录下

2. 目录结构如下：

   ioc

   - beanFactory
     - singletonObjects【ioc.getBean（）】

```java
ApplicationContext ioc = new ClassPathXmlApplicationContext("beans.xml");
System.out.println("ok");
Monster monster01 = (Monster) ioc.getBean("monster01");
System.out.println(monster01);
System.out.println("monster01.name= " + monster01.getName());
```

注意：只要初始化 Ioc 容器，这个容器就会把非懒加载的 bean 全部给你创建起来

## 2. 单例和多例

单例：scope="singleton"，在 singleton中只会有一个这样的 bean 对象，当执行 getBean() 时，返回的都是同一对象

多例：scope="prototype"，每次 getBean 都返回一个全新的对象

------

使用细节：

1. 单例下，如果希望在 getBean 时才创建，可以指定懒加载 lazy-init="true"（注意默认是：false）
2. 多例下，由于不知道初始时要创建多少个对象，所以无论是否为懒加载，都不会默认创建对象，都是在 getBean 时才会创建对象

## 3. Bean 的生命周期

bean 对象创建由 JVM 完成的，然后执行如下方法：

1. 构造器
2. set方法
3. 调用  bean  的初始化方法 init() 【需要配置】
4. 使用 Bean
5. 当容器关闭时候，调用 bean 的 destroy 方法【需要配置】

```java
//  测试 bean 生命周期
@Test
public void testBeanLife(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("beans2.xml");
    House house = ioc.getBean("house", House.class);
    System.out.println("house=" + house);

    //  关闭容器【向下转型】
    ((ClassPathXmlApplicationContext)ioc).close();
}
```

## 4. Bean 的后置处理器【本质：一个 bean 对象】：实现 BeanPostProcessor 接口

```java
package com.llq.spring.bean;

/**
 * 这是一个后置处理器对象
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    /**
     * 什么时候被调用：在 bean的 init 方法前被调用
     * @param bean：在IOC 容器中创建 / 配置 的 Bean
     * @param beanName：在 IOC 容器中创建 / 配置 Bean 的 id
     * @return Object：程序员对传入的 bean 进行修改和处理【如果有需要的话】，并返回
     * @throws BeansException
     */
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization()... bean=" + bean + "beanName" + beanName);
        return bean;
    }

    /**
     * 什么时候被调用：在 bean的 init 方法后 被调用
     * @param bean
     * @param beanName
     * @return
     * @throws BeansException
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization()... bean=" + bean + "beanName" + beanName);
        return bean;
    }
}
```

说明：

1. 如何执行到这个方法？

   使用 AOP【反射 + 动态代理 + IO + 容器 + 注解】

2. 有什么用？

   对 IOC 容器中所有对象统一管理：日志、权限、安全、事务

   例如：将类型是 House 的统一改为上海豪宅

3. 针对容器的所有对象？

   是的 ===> 切面编程特点

### 使用 XML 方式配置：

```xml
<!-- 开启基于注解的 AOP 功能-->
<aop:aspectj-autoproxy/>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- 配置 House 对象 -->
    <bean class="com.llq.spring.bean.House" id="house" init-method="init" destroy-method="destroy">
        <property name="name" value="四合院"/>
    </bean>

    <!-- 配置后置处理器对象
        解读：
        1. 当我们在 beans3.xml 容器配置文件，配置了 MyBeanPostProcessor
        2. 这是后置处理器对象，就会作用在该容器创建的对象
    -->
    <bean class="com.llq.spring.bean.MyBeanPostProcessor" id="myBeanPostProcessor"/>
</beans>
```

```java
package com.llq.spring.process;
/**
 * 编写一个后置处理器
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization()被 调 用" + beanName + "bean= " + bean.getClass());

        return bean; //	这里如果你返回 null 的话，不会对 bean 产生影响，bean 就是没做修改的 bean
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization()被 调 用" + beanName + "bean" + bean.getClass());

        return bean;
    }
}
```

### 使用注解方式配置

开启注解的 AOP 功能：使用 @EnableAspectJAutoProxy 注解

```java
package com.llq.spring.aop;

@EnableAspectJAutoProxy	//	【开启自动代理】使得 Aspect 注解生效
@Aspect	//	切面类
@Component
public class SmartAspect {
    @Pointcut(value = "execution(public double com.llq.spring.aop.Animal.getSum(double, double))")
    public void myPointCut(){

    }

    @Before(value = "myPointCut()")
    public void f1(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("切面类 f1 方法名-" + name + " -方法执行前日志");
    }

    @AfterReturning(value = "myPointCut()", returning = "res")
    public void f2(JoinPoint joinPoint, Object res){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("切面类 f2 方法名-" + name + " -方法执行后日志，结果为：" + res);
    }

    @AfterThrowing(value = "myPointCut()", throwing = "e1")
    public void f3(JoinPoint joinPoint, Throwable e1){  //  注意异常类型是：Throwable
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("切面类 f3 方法名-" + name + " -方法执行出现异常，异常为：" + e1);
    }
    @After(value = "myPointCut()")
    public void f4(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("切面类 f4 方法名-" + name + " -方法最终执行完毕");
    }
}
```



#### 分析 Spring AOP 和 BeanPostProcessor【Bean后置处理器】关系

我们启用的 AOP功能，实际上是靠 BeanPostProcessor 来支撑的！！！

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202309181023949.png)

![image-20230918104955019](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202309181049316.png)

解读：

- AOP底层是基于 BeanPostProcessor 机制的
- 即在 Bean 创建好后，根据是否需要 AOP处理
  - 需要：返回代理对象（用接口类型来接收）===> 在 postProcessAfterInitialization 方法中打印已经是 Proxy  类型的了
  - 不需要：返回原生 Bean
- 本质： BeanPostProcessor 机制 + 动态代理技术

相关配置整理：

|                                                              | 注解方式                                                     | XML方式                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 开启 AOP 功能（使得 @Aspect 生效）                           | @EnableAspectJAutoProxy                                      | <aop:aspectj-autoproxy/>                                     |
| 切面类 **优先级 **指定                                       | @Order(value=n) 【n 越小，优先级越高】                       | <aop:aspect ref="smartAnimalAspect" order="1">               |
| **切入点表达式** 在前面类方法上增加注解@Pointcut 通过方法名复用 | @Pointcut(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))") // 定义一个切入点，在后面使用时可以直接引用，提高复用性 public void **myPointCut**(){} | <aop:pointcut id="myPoint" expression="execution(public int com.llq.spring.aop.homework1.MyCal.*(int))"/> |
| 横切关注点【1. 前置通知】                                    | @Before                                                      | <aop:before method="f1" pointcut-ref="myPoint"/>             |
| 横切关注点【2. 返回通知】                                    | @AfterReturning                                              | <aop:after-returning method="f2" pointcut-ref="myPoint"/>    |
| 横切关注点【3. 异常通知】                                    | @AfterThrowing                                               | <aop:after-throwing method="f3" pointcut-ref="myPointCut" throwing="e1"/> |
| 横切关注点【4. 最终通知】                                    | @After                                                       | <aop:after method="f4" pointcut-ref="myPointCut"/>           |
| 动态代理                                                     | **返回一个代理对象** Proxy.newProxyInstance( 类加载器、 真正要代理【执行】的对象的接口信息、 调用处理器 **InvocationHandler**) | 类加载器 bean.getClass().getClassLoader()  被代理对象的接口信息 bean.getClass().getInterfaces()  调用处理器：[传入一个匿名内部类] new InvocationHandler() 实现方法 |

## 5. 基于 XML的 Bean的自动装配

1. 通过类型：autowire = "byType"
2. 通过名字：autosire = "byName"

## 6. 基于注解配置 Bean的自动装配

@Component：Bean

@Repository：DAO

@Service：Service

@Controller：Servlet（Controller）

配置容器要扫描的包：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    
    <!-- 配置容器要扫描的包
        1. component-scan 要对指定的包下的类进行扫描，并创建对象到我们的容器中
        2. base-package 指定要扫描的包
        3. 含义是：当 spring 容器创建 / 初始化时，就会扫描这个包下的所有
           有 @Controller、@Service、@Dao、@repository 的类
           并将其实例化，生成对象，放入到 ioc 容器中
    -->
    <context:component-scan base-package="com.llq.spring.component"/>
</beans>
```

自动装配：

| 第一轮                     | 第二轮 |                            |
| -------------------------- | ------ | -------------------------- |
| @Autowired【泛型依赖注入】 | 类型   | id【待装配的属性的属性名】 |
| @Resourse                  | id     | 类型                       |

@Autowire：默认是类型，可以指定为：id

此外：@Autowired 配合 @Qualifier(value="userService02") 指定 id 装配

@Resource：默认是id，可以指定为：类型

```java
@Resource(name = "userService")	// @Resuource 注解 name ===> id
@Resource(type = UserService.class)  // 表示按照 UserService.class 类型进行装配，这时要求容器中，只能有一个这样类型的对象
```

![image-20230912193850180](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202309121938357.png)

## 7. AOP（Aspect Oriented Programming）作用在哪个类的哪个方法

### 动态代理

java 反射包下：Proxy.newProxyInstance（类加载器，真正要代理的对象的接口信息，调用处理器的 InvocationHandler）

```java
//	属于反射包下
//	该类返回一个代理对象
//	1. loader：类加载器
//	2. interfaces：就是真正要代理【执行】的对象的接口信息【现在是：target_vehicle】
//	3. InvocationHadler h：调用处理器（是一个对象），有一个非常重要的方法 invoke
package java.lang.reflect;

@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h) {
    Objects.requireNonNull(h);

    final Class<?> caller = System.getSecurityManager() == null
        ? null
        : Reflection.getCallerClass();

    /*
         * Look up or generate the designated proxy class and its constructor.
         */
    Constructor<?> cons = getProxyConstructor(caller, loader, interfaces);

    return newProxyInstance(caller, cons, h);
}
```

调用处理器 InvocationHandler【是一个接口，下面有 invoke() 方法】

```java
//	这个 invoke 方法是将来执行我们的 target_vehicle的方法时，会调用
package java.lang.reflect;

public interface InvocationHandler {
	//	调用处理器有一个非常重要的方法 invoke
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
//	因为 invoke 方法是在接口中的，所以是一个抽象方法，并没有方法体 ===> 那么怎么搞定这样一个接口呢？？？
//	---> 匿名内部类
```

### AOP

1. 基本介绍

   ```bash
   aspectJ
   ├─ Animal.java
   ├─ SmartAnimal.java
   └─ SmartAnimalAspect.java	# 切面类
   ```

2. 实现机制：

   - 基于动态代理的方式
   - 使用框架 Aspectj 来实现

3. 快速入门

   1. 需要引入核心的 aspect 包

   2. 在切面类声明通知方法

      - 前置通知：@Before
      - 返回通知：@AfterReturning
      - 异常通知：@AfterThrowing
      - 后置（最终）通知：@After
        - 环绕通知：@Aroud

      ```java
      package com.llq.spring.aop.aspectJ;
      
      /**
       * 切面类
       * 类似我们之前写的 MyProxyProvider，但是功能强大很多
       */
      @Aspect //  切面类【底层切面编程的支撑（动态代理 + 反射 + 动态绑定 ...）】
      @Component  //  Spring 容器会注入 SmartAnimalAspect
      public class SmartAnimalAspect {
          //  希望将 f1() 方法切入到 Animal 的 getSum 前执行 ===> 前置通知
          
          /**
           * 解读
           * 1. @Before：表示 前置通知【目标对象执行方法前执行】
           * 2. value = "execution(指定 切入到哪个类的 哪个方法)"
           *      形式为：访问修饰符  + 返回类型 + 全类名.方法名(形参列表) ===> 为什么带形参列表？【可能方法名相同，进行了方法重载】
           * 3. f1(JoinPoint joinPoint) 方法可以理解成就是一个切入方法，方法名由程序员指定 【一般为：showBeginLog】
           *
           * @param joinPoint：在底层执行时，由 AspectJ切面编程框架，会给该切入方法传入 JoinPoint 对象
           *                   通过该对象方法，程序员可以得到 相关信息
           */
          @Before(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
          public static void f1(JoinPoint joinPoint){
              //  通过连接点对象 joinPoint 可以拿到方法签名
              Signature signature = joinPoint.getSignature();
              String name = signature.getName();		//	方法名字
              Object[] args = joinPoint.getArgs();    //  同理，拿到参数
      
              List<Object> objects = Arrays.asList(args);
              System.out.println("方法名-" + name + "-参数" + objects.toString()); //  1. 横切关注点：前置通知
          }
      }
      ```

      现在是基于注解来玩的，所以先定义扫描位置：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:context="http://www.springframework.org/schema/context"
             xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
          <!--现在是基于注解来玩的，所以先定义扫描位置-->
          <context:component-scan base-package="com.llq.spring.aop.aspectJ"/>
      </beans>
      ```

4. 注意事项：

   1. 关于切面类方法命名规范性，比如：

      - showBeginLog()
      - showSuccessEndLog()
      - showExceptionLog()
      - showFinallyEndLog()

   2. 切入表达式的更多配置，比如：使用模糊配置 ====> 切入到哪个类的哪个方法

      - 第一个 *：该类任意修饰符（public、default、protected、private）的方法，同时也不管返回类型 【public doule】
      - 第二个*：该类下所有的方法
      - .. ：不管形参如何，统统执行

      ```bash
      @Before(value="execution(* com.hspedu.aop.proxy.SmartDog.*(..))")
      ```

   3. 表示所有访问权限，所有包的下所有有类的所有方法，都会被执行该前置通知方法

      - 前提是扫描的包下的【本质还是要基于动态代理去获取的那些对象，才能生效，你普通的对象是切不进去的！！！】

        ```bash
        @Before(value="execution(* *.*(..))")
        ```

   4. 当spring 容器开启了

      ```xml
      <!-- 开启基于注解的AOP 功能--> 
      <aop:aspectj-autoproxy/> 
      ```

      我们获取注入的对象, 需要 **以接口的类型** 来获取, 因为你 注入的对象.getClass() 已经是代理类型 了

      ```java
      package com.llq.spring.proxy2;
      
      public class TestVehicle {
         @Test
         public void ProxyRun(){
             //  1. 创建 VehicleProxyProvider 对象，并传入我们要代理的对象 new Car() 【target_vehicle】
             VehicleProxyProvider vehicleProxyProvider = new VehicleProxyProvider(new Car());
             //  2. 获取代理对象 ===> 该对象可以代理执行方法
             //   proxy 的编译类型：Vehicle
             //             运行类型： 【⭐代理类型⭐】
             Vehicle proxy = vehicleProxyProvider.getProxy();
             System.out.println("proxy的运行类型" + proxy.getClass()); // class com.sun.proxy.$Proxy7
      
             //   那么也就是说，我们再来执行 run() 方法的话
             //   它就不会再去找 Car 中的 run() 方法了
             //   而是去找  代理对象的 invocationHandler 里面的 invoke() 方法了！！！
             proxy.run();
         }
      }
      ```

   5. 当spring 容器开启了

      ```xml
      <!-- 开启基于注解的AOP 功能--> 
      <aop:aspectj-autoproxy/> 
      ```

      我们获取注入的对象, 也可以通过id 来获取, 但是也要转成接口类型.

### 切入表达式

1. 作用：

   通过 **表达式的方式** 定位 **一个或多个** 具体的连接点

2. 语法细节：

   | 语法格式                                                     | execution( [权限修饰符] [返回值类型] [简单类名 / 全类名] [方法名] ([参数列表]) ) |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | execution(* com.sina.spring.ArithmetricCalculator.*(..))     | ArithmetricCalculator 接口中声明的所有方法 第一个 * ：任意修饰符及返回值 第二个 * ：任意方法 .. ：匹配任意数量、任意类型的参数 若目标类、接口与该切面类在同一个包中可以省略包名 |
   | execution(public * ArithmetricCalculator.*(..))              | ArithmetricCalculator 接口的所有的公共方法                   |
   | execution(public double ArithmetricCalculator.*(..))         | ArithmetricCalculator 接口返回 double 类型数值的方法         |
   | execution(public double ArithmetricCalculator.*(double, ..)) | 第一个参数为：double 类型的方法 .. ：匹配任意数量、任意类型的参数 |
   | execution(public double ArithmetricCalculator.*(double, double)) | 参数类型为 double，double 类型的方法                         |
   | execution(* *.add(int, ..)) \|\| execution(* *.sub(int, ..)) | 在 Aspectl 中，切入表达式可以通过 "&&"、"\|\|"、"!" 等操作符结合起来 任意一个第一个参数为 int 类型的 add 方法 或者 sub 方法 |

3. 注意事项：

   - 切入表达式指向类的方法，这时切入表达式会对 该类/对象生效

   - 切入表达式也可以指向接口的方法，这时切入表达式会对实现了接口的类 / 对象生效

     ```java
     //	比如：下面我们是对 UsbInterface 切入，那么对实现类 Phone 和 Camera 对象都作用了！！！	
     package com.llq.spring.aop.homework;
     
     @Component
     @Aspect
     public class SmartAnimalAspect {
     
         //  1. 前置通知
         @Before(value = "execution(public void UsbInterface.work())")
         public void showBeginLog(JoinPoint joinPoint){
             //  通过连接点对象 joinPoint 可以拿到方法签名
             Signature signature = joinPoint.getSignature();
             String name = signature.getName();
             System.out.println("切面类showBeginLog() 方法名-" + name + "-执行前日志"); //  1. 横切关注点：前置通知
         }
     }
     ```

### 两个动态代理的区别

| 面向                  | 增强 | 得到对象【ioc.getBean()】          | 得到对象【ioc.getBean()】 |
| --------------------- | ---- | ---------------------------------- | ------------------------- |
| JDK Proxy 动态代理    | 接口 | 只能增强实现类中，接口中存在的方法 | jdk 代理对象实例 proxy    |
| Spring CGlib 动态代理 | 父类 | 可以增强父类的所有方法             | 被代理对象的子类          |

### JoinPoint

通过JoinPoint 可以获取到调用方法的签名

```java
//	得到调用方法的方法签名
Signature signature = joinPoint.getSignature();
```

应用实例：

在调用前置通知获取到调用方法的签名, 和其它相关信息

| 方法                                         | 作用                                             |
| -------------------------------------------- | ------------------------------------------------ |
| signature.getName()                          | 获取目标方法名                                   |
| signature.getDeclaringType().getSimpleName() | 目标方法所属类的 简单类名                        |
| signature.getDeclaringTypeName();            | 获取目标方法所属类的类名                         |
| signature.getModifiers()                     | 获取目标方法声明类型(public、private、protected) |
| Object[] args = joinPoint.getArgs();         | 获取传入目标方法的参数，返回一个数组             |
| joinPoint.getTarget()                        | 获取被代理的对象                                 |
| joinPoint.getThis()                          | 获取代理对象自己【Proxy、CGlib】                 |

###  返回通知获取结果

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface AfterReturning {
    String value() default "";

    String pointcut() default "";

    String returning() default ""; 	//	返回的结果

    String argNames() default "";
}
```

![image-20230916125652942](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202309161257072.png)

```java
// 1. 如果我们希望目标方法，执行的结果，返回给切入方法
// 2. 可以在 @AfterReturning 注解内，增加一个属性，比如：returning = "res"
// 3. 同时在 切入方法增加 Object res
// 4. 注意：returning = "res" 和 Object res 的 名称要一致
@AfterReturning(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))", returning = "res")
//  2. 返回通知
public void f2(JoinPoint joinPoint, Object res){
    Signature signature = joinPoint.getSignature();
    String name = signature.getName();

    System.out.println("切面类f2() 方法名-" + name + " -方法正常结束执行后日志---> 目标方法返回的结果：" + res);
}
```

### 异常通知中获取异常

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface AfterThrowing {
    String value() default "";

    String pointcut() default "";

    String throwing() default "";	//	异常信息

    String argNames() default "";
}
```

```java
//  3. 异常通知
@AfterThrowing(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))", throwing = "e1")
public void f3(JoinPoint joinPoint, Throwable e1){
    Signature signature = joinPoint.getSignature();
    String name = signature.getName();

    System.out.println("切面类f3() 方法名-" + name + " -方法出现异常 ---> 异常信息：" + e1);
}
```

### 环绕通知

环绕通知可以完成其它四个通知要做的事情

### 切入点表达式重用【建立一个方法，加上@Pointcut 注解，这个方法名称就可以被服用了】

为了统一管理切入点表达式，可以使用切入点表达式重用技术。

```java
package com.llq.spring.aop.aspectJ;

/**
 * 切面类
 */
@Aspect //  切面类【底层切面编程的支撑（动态代理 + 反射 + 动态绑定 ...）】
@Component  //  Spring 容器会注入 SmartAnimalAspect
public class SmartAnimalAspect {
    @Pointcut(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
    //  定义一个切入点，在后面使用时可以直接引用，提高复用性
    public void myPointCut(){}

    /**
     * 解读
     * 1. @Before：表示 前置通知【目标对象执行方法前执行】
     * 2. value = "execution(指定 切入到哪个类的 哪个方法)"
     *      形式为：访问修饰符  + 返回类型 + 全类名.方法名(形参列表) ===> 为什么带形参列表？【可能方法名相同，进行了方法重载】
     * 3. f1(JoinPoint joinPoint) 方法可以理解成就是一个切入方法，方法名由程序员指定 【一般为：showBeginLog】
     *
     * @param joinPoint：在底层执行时，由 AspectJ切面编程框架，会给该切入方法传入 JoinPoint 对象
     *                   通过该对象方法，程序员可以得到 相关信息
     */

    //  1. 前置通知
    // @Before(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
    //  这里使用定义好的切入点
    @Before(value = "myPointCut()")
    public void f1(JoinPoint joinPoint){
        //  通过连接点对象 joinPoint 可以拿到方法签名
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        Object[] args = joinPoint.getArgs();    //  同理，拿到参数


        List<Object> objects = Arrays.asList(args);
        System.out.println("切面类f1() 方法名-" + name + "-执行前日志：-参数" + objects.toString()); //  1. 横切关注点：前置通知
    }

    // 1. 如果我们希望目标方法，执行的结果，返回给切入方法
    // 2. 可以在 @AfterReturning 注解内，增加一个属性，比如：returning = "res"
    // 3. 同时在 切入方法增加 Object res
    // 4. 注意：returning = "res" 和 Object res 的 名称要一致
    // @AfterReturning(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))", returning = "res")
    //  2. 返回通知
    @AfterReturning(value = "myPointCut()", returning = "res")
    public void f2(JoinPoint joinPoint, Object res){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f2() 方法名-" + name + " -方法正常结束执行后日志---> 目标方法返回的结果：" + res);

    }

    //  3. 异常通知

    // @AfterThrowing(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))", throwing = "e1")
    @AfterThrowing(value = "myPointCut()", throwing = "e1")
    public void f3(JoinPoint joinPoint, Throwable e1){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f3() 方法名-" + name + " -方法出现异常 ---> 异常信息：" + e1);
    }

    //  4. 最终通知：即把方法 f4 切入到目标方法执行后（不管是否发生异常，都要执行，类似 finally{}）
    // @After(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
    @After(value = "myPointCut()")
    public void f4(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f4() 方法名-" + name + " -方法最终执行完毕");
    }
}
```

### 切面优先级问题【给切面类添加注解 @Order(value=n)，n 越小，优先级越高】

如果同一个方法，有多个切面在同一个切入点切入，那么执行的优先级如何控制

基本语法：

```bash
# n 值越小，优先级越高
@Order(value=n) 
```

### 基于 XML 配置 AOP

前面我们是通过注解来配置aop 的，在spring 中，我们也可以通过xml 的方式来配置AOP

```java
package com.llq.spring.aop.xml;

/**
 * 切面类 ===> 但是不用注解，使用 XML 配置
 */

public class SmartAnimalAspect {
    public void f1(JoinPoint joinPoint){
        //  通过连接点对象 joinPoint 可以拿到方法签名
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        Object[] args = joinPoint.getArgs();    //  同理，拿到参数


        List<Object> objects = Arrays.asList(args);
        System.out.println("切面类f1() 方法名-" + name + "-执行前日志：-参数" + objects.toString()); //  1. 横切关注点：前置通知
    }

    public void f2(JoinPoint joinPoint, Object res){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f2() 方法名-" + name + " -方法正常结束执行后日志---> 目标方法返回的结果：" + res);

    }

    public void f3(JoinPoint joinPoint, Throwable e1){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f3() 方法名-" + name + " -方法出现异常 ---> 异常信息：" + e1);
    }

    public void f4(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f4() 方法名-" + name + " -方法最终执行完毕");
    }
}
```

XML配置信息

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 使用 XML 配置，完成AOP 编程-->
    <!-- 1. 配置切面类 Bean-->
    <bean class="com.llq.spring.aop.xml.SmartAnimalAspect" id="smartAnimalAspect"/>

    <!-- 2. 配置目标类 Bean-->
    <bean class="com.llq.spring.aop.xml.Animal" id="animal"/>

    <!-- 3. 配置切面类关系 -->
    <aop:config>
        <!-- 配置切入点表达式 -->
        <aop:pointcut id="myPointCut" expression="execution(public double com.llq.spring.aop.xml.Animal.getSum(double, double))"/>
        <!-- 配置切面的前置，返回，异常，最终通知-->
        <aop:aspect ref="smartAnimalAspect" order="1">	<!-- 切面类 -->
            <!-- 配置前置通知 -->
            <aop:before method="f1" pointcut-ref="myPointCut"/>
            <!-- 配置返回通知-->
            <aop:after-returning method="f2" pointcut-ref="myPointCut" returning="res"/>
            <!-- 配置异常通知-->
            <aop:after-throwing method="f3" pointcut-ref="myPointCut" throwing="e1"/>
            <!-- 配置最终通知-->
            <aop:after method="f4" pointcut-ref="myPointCut"/>
        </aop:aspect>
    </aop:config>
</beans>
```

## 8. JdbcTemplate

Spring框架处理数据库：

- 方案1. 使用前面做项目开发的JdbcUtils 类
- 方案2. 其实 spring 提供 了一个操作数据库(表)功能强大的类 <font color="yellow">**JdbcTemplate**</font> 。我们可以同 ioc 容器来配置一个jdbcTemplate 对象，使用它来完成对数据库表的各种操作.

创建配置文件 src/jdbc.properties【数据库配置】

```properties
jdbc.userName=root
jdbc.password=352420kobe24llq
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/spring
```

创建配置文件 src/JdbcTemplate_ioc.xml【Spring 配置】

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 引入外部的 JDBC.properties文件 -->
    <context:property-placeholder location="classpath:JDBC.properties"/>

    <!--JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个 接口，该接口由第三方提供实现【提供 .jar包】
        1. CP30
        2. DBCP数据库连接池
        3. Proxool
        4. BoneCP
        5. Druid：阿里提供的数据库连接池，集 DBCP，C3P0，Proxool，优点于一身的数据库连接池
    -->
    <!-- 配置数据源对象==DataSource== -->
    <bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="dataSource">
        <!--给数据源对象，配置属性值-->
        <property name="user" value="${jdbc.userName}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="driverClass" value="${jdbc.driver}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
    </bean>

</beans>
```

测试下：

```java
package com.llq.spring.test;

public class JDBCTemplateTest {
    @Test
    public void testJDBCTemplate(){
        ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
        ComboPooledDataSource dataSource = ioc.getBean("dataSource", ComboPooledDataSource.class);
        try {
            Connection connection = dataSource.getConnection();
            System.out.println(connection);	//	代理连接对象
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

数据源的连接：其实是一个 **代理连接对象**，是通过数据连接池返回的连接

### CRUD

1. 配置 JdbcTemplate 对象

2. 给 JdbcTemplate 对象配置 dataSource 属性

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
   
       <!--现在是基于注解来玩的，所以先定义扫描位置-->
       <context:component-scan base-package="com.llq.spring.jdbctemplate"/>
   
       <!-- 引入外部的 JDBC.properties文件 -->
       <context:property-placeholder location="classpath:JDBC.properties"/>
   
       <!--JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个 接口，该接口由第三方提供实现【提供 .jar包】
           1. CP30
           2. DBCP数据库连接池
           3. Proxool
           4. BoneCP
           5. Druid：阿里提供的数据库连接池，集 DBCP，C3P0，Proxool，优点于一身的数据库连接池
       -->
       <!-- 配置数据源对象==DataSource== -->
       <bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="dataSource">
           <!--给数据源对象，配置属性值-->
           <property name="user" value="${jdbc.userName}"/>
           <property name="password" value="${jdbc.password}"/>
           <property name="driverClass" value="${jdbc.driver}"/>
           <property name="jdbcUrl" value="${jdbc.url}"/>
       </bean>
   
       <!-- 配置 JdbcTemplate 对象 -->
       <bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate">
           <!-- 给 JdbcTemplate 对象配置 dataSource 属性-->
           <property name="dataSource" ref="dataSource"/>
   
       </bean>
   </beans>
   ```

#### 插入

```java
//	1. execute
String sql = "Insert into monster values(400, '小龙女', '枪法')";
jdbcTemplate.execute(sql);
//	2. update
String sql1 = "Insert into monster values(?, ?, ?)";
//  执行后，表受影响的记录数
int affectedRows = jdbcTemplate.update(sql1, 500, "关羽", "大鹏展翅");	//	update：解决 sql 注入的问题
System.out.println(affectedRows);
```

#### 修改

```java
@Test
public void updateDataByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);

    String sql = "update monster set skill=? where id=?";
    int affectedRows = jdbcTemplate.update(sql, "无影刀", 400);
    System.out.println(affectedRows);
}
```

#### 批量处理

```java
//  批量添加 3 个 monster 张飞、飞天德、哪吒
//  这里有一个使用 API 技巧
//      1. 确定 API名字
//      2. 根据 API 提供相应的参数【组织参数】
//      3. 将自己的调用思路清晰
//  batchUpdate(String sql, List<Object[]> batchArgs)
@Test
public void BatchUpdateByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    List<Object[]> batchArgs = new ArrayList<>();

    Object[] objects = new Object[]{600, "张飞", "蛮牛式"};
    String[] strings = new String[]{"1", "22"};

    String sql = "Insert into monster values(?, ?, ?)";
    batchArgs.add(new Object[]{600, "张飞", "蛮牛式"});
    batchArgs.add(new Object[]{700, "飞天德", "飞天"});
    batchArgs.add(new Object[]{800, "哪吒", "三味真火"});

    int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
    for (int anInt : ints) {
        System.out.println("anInt= " + anInt);
    }
}
```

#### 查询后封装成对象

```java
//  查询 id = 100 的 monster，并封装成 Monster 对象【实际开发中，非常有用！！！】
@Test
public void selectDataByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    //  组织 sql
    String sql = "select id monsterId, `name`, skill from monster where id = 100";
    //  通过 BeanPropertyRowMapper 读取， rowMapper 是一个接口，可以将查询的结果，封装到你指定的 Monster 对象中
    //  使用 RowMapper 接口来对返回的数据，进行一个封装 ===> 底层使用的是 反射 ===> setter 方法
    //  这里有一个细节：你查询的记录的表的字段需要和 Monster对象字段名保持一致【通过 mysql 重命名表头 as】
    RowMapper<Monster> rowMapper = new BeanPropertyRowMapper<>(Monster.class);  //  反射的时候，需要 class 对象

    // public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)

    Monster monster = jdbcTemplate.queryForObject(sql, rowMapper);
    System.out.println("monster= " + monster);
}
```

查询 id > 200 的 monster，并封装成 Monster 对象

```java
@Test
public void selectMultiDataByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    //  组织 sql
    String sql = "select id monsterId, `name`, skill from monster where id >= ?";

    RowMapper<Monster> rowMapper = new BeanPropertyRowMapper<>(Monster.class);  //  反射的时候，需要 class 对象
    List<Monster> monsters = jdbcTemplate.query(sql, rowMapper, 200);
    for (Monster monster : monsters) {
        System.out.println("monster= " + monster);
    }
}
```

#### 返回单行单列

```java
@Test
public void selectScalaByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    //  确定 API
    //  public <T> T queryForObject(String sql, Class<T> requiredType)

    //  组织 sql
    String sql = "select `name` from monster where id = ?";

    String s = jdbcTemplate.queryForObject(sql, String.class, 500);

    System.out.println("id = 500 的名字是：" + s);
}
```

#### 使用 Map传入具名参数完成操作

```xml
<!-- 配置 NamedParameterJdbcTemplate 对象-->
<bean class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate" id="namedParameterJdbcTemplate">
    <!-- 通过构造器，设置数据源-->
    <constructor-arg name="dataSource" ref="dataSource"/>
</bean>
```

```java
@Test
public void testDataByNameParameterByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    NamedParameterJdbcTemplate namedParameterJdbcTemplate = ioc.getBean("namedParameterJdbcTemplate", NamedParameterJdbcTemplate.class);

    //  确定 API
    // public int update(String sql, Map<String, ?> paramMap) throws DataAccessException {

    //  组织 sql
    String sql = "Insert into monster values(:id, :name, :skill)";
    //  准备参数 [:my_id, :name, :skill] 要求按照规定的的名字来设置参数
    Map<String, Object> map = new HashMap<>();
    map.put("id", 900);
    map.put("name", "蚂蚁精");
    map.put("skill", "挖洞");
    int affectedRows = namedParameterJdbcTemplate.update(sql, map);
    System.out.println(affectedRows);
}
```

#### 使用 sqlparametersource  来封装具名参数

```java
@Test
public void operDataBySqlparametersource(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    NamedParameterJdbcTemplate namedParameterJdbcTemplate = ioc.getBean("namedParameterJdbcTemplate", NamedParameterJdbcTemplate.class);
    //  1. 确定 API
    // public int update(String sql, SqlParameterSource paramSource)
    // public BeanPropertySqlParameterSource(Object object)
    Monster monster = new Monster(1000, "虹猫", "长虹剑");   //  现在是以对象传进去的！！！
    SqlParameterSource sqlParameterSource = new BeanPropertySqlParameterSource(monster);
    //  2. 准备参数
    String sql = "Insert into monster values(:monsterId, :name, :skill)";

    //  3. 调用
    int affectedRows = namedParameterJdbcTemplate.update(sql, sqlParameterSource);
    System.out.println(affectedRows);
}
```

#### DAO使用 jdbcTemplate

```java
package com.llq.spring.jdbctemplate.dao;

@Repository //  将 MonsterDao 注入到 Spring 容器
public class MonsterDao {
    //  注入一个属性
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //  完成保存任务
    public void save(Monster monster){
        //  组织 sql 语句
        String sql = "Insert into monster values(?, ?, ?)";
        int affectedRows = jdbcTemplate.update(sql, monster.getMonsterId(), monster.getName(), monster.getSkill());
        System.out.println("affectedRows= " + affectedRows);
    }
}
```

测试：

```java
@Test
public void testDaoSave(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    MonsterDao monsterDao = ioc.getBean("monsterDao", MonsterDao.class);
    monsterDao.save(new Monster(1001, "蓝兔", "冰魄剑"));
}
```

### 9. 声明式事务【传统编程式事务代码冗余，可以将3个子步骤分别写一个方法，然后统一管理】

传统方式我们使用的是编程式事务

```java
Connection connection = JdbcUtils.getConnection();
try {
    //1. 先设置事务不要自动提交
    connection.setAutoCommint(false);
    //2. 进行各种crud
    //多个表的修改，添加，删除
    //3. 提交
    connection.commit();
} catch (Exception e) {
    //4. 回滚
    conection.rollback();
}
```

下面讲述声明式事务【购买商品】：

我们需要去处理用户购买商品的业务逻辑:分析: 当一个用户要去购买商品应该包含三个步骤

1. 通过商品id 获取价格
2. 购买商品(某人购买商品，修改用户的余额
3. 修改库存量

其实大家可以看到，这时，我们需要涉及到三张表商品表，用户表，商品存量表。应该使用事务处理

#### 编程式事务实现

使用传统的编程事务来处理，将代码写到一起

- 缺点: 代码冗余，效率低，不利于扩展
- 优点：简单，好理解

```java
Connection connection = JdbcUtils.getConnection();
try {
    //1. 先设置事务不要自动提交
    connection.setAutoCommit(false);
    //2. 进行各种crud
    //多个表的修改，添加，删除
    select from 商品表=> 获取价格
        修改用户余额update ...
        修改库存量update
    //3. 提交
 	connection.commit();
} catch (Exception e) {
    //4. 回滚
    conection.rollback();
}
```

#### 声明事务实现【@Transactional】

使用Spring 的声明式事务处理， 可以将上面三个子步骤分别写成一个方法，然后统一管理

- 这个是Spring 很牛的地方，在开发使用的很多，优点是无代码冗余，效率高，扩展方便，缺点是理解较困难
- 底层使用AOP (动态代理+动态绑定+反射+注解) => 看Debug 源码.

```java
//  编写一个方法完成用户购买商品业务
//  1. 使用 Transactional 可以进行声明式事务控制
//  2. 即将标识的方法中的，对数据库的操作作为一个事务管理
@Transactional
public void buyGoodsByTx(int userId, int goodsId, int amount){
    System.out.println("用户购买信息 userId= " + userId + "goodsId= " + goodsId + "amount= " + amount);
    Float price = goodsDao.queryPriceById(goodsId);    //  价格
    goodsDao.updateBalance(userId, price * amount);    //  减少用户余额 【先付款，后减少库存量】

    goodsDao.updateAmount(goodsId, amount); //  减少库存量
}
```

```xml
<!-- 配置事务管理器=== 对象
        1. DataSourceTransactionManager 这个对象是进行事务管理 === debug源码
        2. 一定要配置数据源属性，这样就指定该事务管理器是对哪个数据源进行事务控制
 -->
<bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="dataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 配置基于注解的声明式事务管理功能 -->
<tx:annotation-driven transaction-manager="dataSourceTransactionManager"/>
```

声明式事务机制：Debug

底层使用 动态代理对象来调用 buyGoodsByTx

1. 先调用 事务管理器的 doBegin()
2. 调用 buyGoodsByTx()
   - 如果执行无异常，则调用 事务管理器 doCommit() 方法
   - 如果发生异常，就会调用事务管理器 doRollback() 方法

##### 事务的传播机制【propagation：传播】

1. 当有多个事务处理并存时，如何控制?
2. 比如用户去购买两次商品(使用不同的方法), 每个方法都是一个事务，那么如何控制呢?
3. 这个就是事务的传播机制，看一个具体的案例(如图)

事务传播的属性/种类一览图

| 传播属性           | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| REQUIRED（默认的） | 如果有事务在运行，当前的方法就在这个事务内运行 否则，就启动一个新的事务，并在自己的事务内运行 |
| REQUIRES_NEW       | 当前的方法必须启动新事务，并在它自己的事务内运行．如果有事务正在运行，应该将它挂起 |
| SUPPORTS           | 如果有事务在运行，当前的方法就在这个事务内运行.否则它可以不运行在事务中. |
| NOT_SUPPORTE       | 当前的方法不应该运行在事务中．如果有运行的事务，将它挂起     |
| MANDATORY          | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
| NEVER              | 当前的方法不应该运行在事务中．如果有运行的事务，就抛出异常   |
| NESTED             | 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行。否则，就启动一个新的事务，并在它自己的事务内运行. |

设置方法

```bash
@Transactional(propagation = Propagation.REQUIRED)

@Transactional(propagation = Propagation.REQUIRES_NEW)
```

REQUIRES_NEW 和REQUIRED 在处理事务的策略

- buyGoods2 如果错误，不会影响到buyGoods()反之亦然，即它们的事务是独立的.
- buyGoods2 和buyGoods 是一个整体，只要有方法的事务错误，那么两个方法都不会执行成功!

##### 事务的隔离级别

| 隔离级别         | 出现问题                                   |
| ---------------- | ------------------------------------------ |
| Read_uncommitted | 脏读【读取别人未提交的】、不可重复读、幻读 |
| Read_committed   | 不可重复读【修改、删除】、幻读【插入】     |
| Repeatable _read |                                            |
| Serializable     |                                            |

##### 超时回滚

1. 如果一个事务执行的时间超过某个时间限制，就让该事务回滚
2. 可以通过设置事务超时来实现

```java
@Transactional(timeout = 2)
```

# SpringMVC【基于Spring 的 Web层 MVC框架】--- 基石：Servlet

SpringMVC是 Web层框架【SpringMVC接管了 Web层组件，比如：控制器视图，视图解析，返回给用户的数据格式，同时支持MVC的开发模式 / 开发架构】

MVC解释：

- Model：javabean、servcie、dao
- View：html、jsp、css
- Controller：Servlet

## 1. 快速入门

创建src/applicationContext-mvc.xml 文件(就是spring 的容器文件)，文件名自己定

- prefix：文件前缀
- suffix：文件后缀
- 然后在 return中填写文件名字

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202309221947449.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <!-- Spring 配置文件 -->

    <!-- 配置自动扫描包-->
    <context:component-scan base-package="com.llq.web"/>

    <!-- 配置视图解析器 -->
    <!-- 在整个容器中，只会有一个视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 配置属性 suffix 和 prefix -->
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
</beans>
```

配置WEB-INF/web.xml ===> 配置 前端控制器 / 中央控制器 / 分发控制器，用户所有的请求都会经过它的处理

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!-- 配置 前端控制器 / 中央控制器 / 分发控制器
        1. 用户的请求都会经过它的处理
    -->
    <servlet>
        <servlet-name>springDispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 配置属性 contextConfigLocation，指定 springDispatcherServlet 去操作的 Spring 配置文件 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext-mvc.xml</param-value>
        </init-param>
        <!--在 web 项目启动时，就自动地加载 DispatcherServlet -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springDispatcherServlet</servlet-name>
        <!-- 老师说明
            1. 这里我们配置的 url-pattern 是 /，表示用户的请求都经过 springDispatcherServlet
            2. 这样配置也支持 rest 风格的 url 请求
        -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

创建登录页面

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>登录</title>
</head>

<body>
<h3>登录页面</h3>
<form action="?">
    u:<input name="username" type="text"> <br/>
    p:<input name="password" type="password"><br/>
    <input type="submit" value="登录">
</form>

</body>
</html>
```

创建 UserServlet

```java
package com.llq.web;

/**
 * 1. 如果使用 SpringMVC，在一个类上标识 @Controller
 * 2. 标识将该列视为一个控制器，注入到我们的 Spring 容器中
 * 3. 比原先的 Servlet 开发要简化很多
 */
@Controller
public class UserServlet { 
    //  编写方法，响应用户的请求

    /**
     * 1. login() 方法用于响应用户的登录请求
     * 2. @RequestMapping(value = "/login") 类似我们以前原生的 Servlet 配置的 url-pattern
     *    就是给 方法配置一个 url 映射
     * 3. 即：当用户在浏览器输入：http://localhost:8080/web工程/login 就能访问到该方法
     * @return "login_ok"：标识返回结果给视图解析器【InternalResourceViewResolver】
     * 视图解析器会根据配置来决定跳转到哪个页面
     */
    @RequestMapping(value = "/login")
    public String login(){
        System.out.println("login OK!!!");
        return "login_ok";
    }
    //  根据上面的配置 return "login_ok"; 就是转发到 /WEB-INF/pages/login_ok.jsp
}
```

## 2. SpringMVC执行流程

![image-20230922225623249](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202309222256388.png)

## 3. RequestMapping

@RequestMapping 注解可以指定 控制器/处理器 的某个方法的请求的url, 基本用法前面我们讲过了, RequestMapping : 请求映射

```java
package com.llq.web;

/**
 * 1. 如果使用 SpringMVC，在一个类上标识 @Controller
 * 2. 标识将该列视为一个控制器，注入到我们的 Spring 容器中
 * 3. 比原先的 Servlet 开发要简化很多
 */
@Controller
public class UserServlet {
    //  编写方法，响应用户的请求

    @RequestMapping(value = "/login")
    public String login(){
        System.out.println("login OK!!!");
        return "login_ok";
    }

    //  根据上面的配置 return "login_ok"; 就是转发到 /WEB-INF/pages/login_ok.jsp
}
```

## 4. Rest 风格的 url：完成CRUD

1. REST：即 Representational State Transfer。(资源)表现层状态转化。是目前流行的请求方式。它结构清晰, 很多网站采用

2. HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：

   - GET 用来获取资源
   - POST 用来新建资源【Save、Add】
   - PUT 用来更新资源【Update】
   - DELETE 用来删除资源

3. 实例：

   ```bash
   # 传统的请求方法:
   getBook?id=1 GET
   delete?id=1 GET
   update POST
   add POST
   ```

4. 说明：

   传统的url 是通过参数来说明crud 的类型，rest 是通过 get/post/put/delete 来说明 crud 的类型

REST 的核心过滤器：

1. 当前的浏览器只支持 post/get 请求，因此为了得到 put/delete 的请求方式需要使用Spring提供的 <font color="yellow">**HiddenHttpMethodFilter** 过滤器</font>进行转换.

   ```bash
   # 将前端发送过来的 put 请求，通过 HiddenHttpMethodFilter 过滤器 转成 SpringMVC的 Put 或者 Delete 请求
   ```

2. HiddenHttpMethodFilter：浏览器form 表单只支持GET 与POST 请求，而DELETE、PUT等method 并不支持，Spring 添加了一个过滤器，可以将这些请求转换为标准的http 方法，使得支持GET、POST、PUT 与DELETE 请求

3. HiddenHttpMethodFilter 能对post 请求方式进行转换，因此我们需要特别的注意这一点

4. 这个过滤器需要在web.xml 中配置

操作 【HiddenHttpMethodFilter 过滤器】：增加 PUT、DELETE 请求方式

1. 修改 web.xml 添加 HiddenHttpMethodFilter

   ```xml
   <filter>
       <filter-name>hiddenHttpMethodFilter</filter-name>
       <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>hiddenHttpMethodFilter</filter-name>
       <url-pattern>/*</url-pattern>
   </filter-mapping>
   ```

2. 修改 applicationContext-mvc.xml

   ```xml
   <!-- 加入两个常规配置-->
   <!-- 能支持SpringMVC 高级功能，比如JSR303 校验，映射动态请求-->
   <mvc:annotation-driven></mvc:annotation-driven>
   <!-- 将SpringMVC 不能处理的请求交给Tomcat, 比如请求css,js 等-->
   <mvc:default-servlet-handler/>
   ```

3. 创建D:\idea_java_projects\springmvc\web\rest.jsp, 注意需要引入jquery, 测试的时候查询/添加/删除/修改一个一个的来

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>rest </title>
       <script type="text/javascript" src="script/jquery-3.6.0.min.js"></script>
       <script type="text/javascript">
           $(function () {
               $("#deleteBook").click(function () {
                   alert("ok");
                   var href = this.href;
                   $("#hiddenForm").attr("action", href);
                   $(":hidden").val("DELETE");
                   $("#hiddenForm").submit();//这里就是提交删除请求了
                   //这里必须返回false,否则会提交两次
                   return false;
               });
           })
       </script>
   </head>
   <body>
   <h3>Rest 风格的crud 操作案例</h3>
   <br>
   <hr>
   <h3>rest 风格的url 查询书籍[get]</h3>
   <a href="user/book/100">点击查询书籍</a>
   <br>
   <hr>
   <h3>rest 风格的url 添加书籍[post]</h3>
   <form action="user/book" method="post">
       name:<input name="bookName" type="text"><br>
       <input type="submit" value="添加书籍">
   </form>
   <br>
   <hr>
   <h3>rest 风格的url, 删除一本书</h3>
   <!--
   1. 这里我们需要将删除方式（get）转成delete 的方式，需要使用过滤器和jquery 来完成
   2. name="_method" 名字需要写成_method 因为后台的HiddenHttpMethodFilter
   就是按这个名字来获取hidden 域的值，从而进行请求转换的.
   -->
   <a href="user/book/100" id="deleteBook">删除指定id 的书</a>
   <form action="" method="POST" id="hiddenForm">
       <input type="hidden" name="_method"/>
   </form>
   <br>
   <hr>
   <h3>rest 风格的url 修改书籍[put]~</h3>
   <form action="user/book/100" method="post">
       <input type="hidden" name="_method" value="PUT">
       <input type="submit" value="修改书籍~">
   </form>
   </body>
   </html>
   ```

   ```xml
   <!--
   1. 这里我们需要将删除方式（get）转成delete 的方式，需要使用过滤器和jquery 来完成
   2. name="_method" 名字需要写成_method 因为后台的HiddenHttpMethodFilter
   就是按这个名字来获取hidden 域的值，从而进行请求转换的.
   -->
   <a href="user/book/100" id="deleteBook">删除指定id 的书</a>
   <form action="" method="POST" id="hiddenForm">
       <input type="hidden" name="_method"/>
   </form>
   ```

   ```java
   //删除[DELETE]
   @DeleteMapping(value = "/book/{id}")
   public String delBook(@PathVariable("id") String id) {
       System.out.println("删除书籍id= " + id);
       //return "success"; // [如果这样返回会报错JSPs only permit GET POST or HEAD]
       return "redirect:/user/success"; //重定向到一个没有指定method 的Handler 方法
   }
   ```

   redirect：/user/success 重定向，会被解析成：/springmvc/user/success

   重定向代码：302

   ```java
   //	如果请求是 /user/success，就请求转发到 success.jsp
   @RequestMapping(value = "/success")
   public String successGeneral(){
       return "success";
   }
   ```

注意事项和细节说明

1. HiddenHttpMethodFilter， 在将post 转成delete / put 请求时，是按 **_method** 参数名来读取的
2. 如果web 项目是运行在Tomcat 8 及以上，会发现被过滤成DELETE 和PUT 请求，到达控制器时能顺利执行，但是返回时（forward）会报HTTP 405 的错误提示：消息JSP 只允许GET、POST 或 HEAD。
3. 解决方式：
   - 使用 Tomcat7
   - 将请求转发（forward）改为请求重定向（redirect）:重定向到一个Handler，由Handler 转发到页面
   - 页面测试时, 如果出现点击修改书籍，仍然走的是删除url ,是因为浏览器原因(缓存等原因), 换成chrome 即可

## 5. SpringMVC 映射请求数据

### 获取参数值

1. 开发中，如何获取到

   ```bash
   http://xxx/url ?参数名=参数值&参数名=参数值
   ```

2. 这个使用的非常广泛，我们看一个案例

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>测试 request parameter</title>
   </head>
   <body>
   <h2>获取到超链接参数值</h2>
   <hr/>
   <a href="vote/vote01?name=hsp">获取超链接的参数</a>
   
   <h1>获取到消息头</h1>
   <hr>
   <a href="vote/vote02">获取http消息头信息</a>
   
   <hr>
   <h1>添加主人信息</h1>
   <!--
   老韩解读
   1. 这是一个表单，表单的数据对应Master对象
   2. 提交的数据参数名和对象的字段名一致即可
   -->
   <form action="vote/vote03" method="post">
       主人号:<input type="text" name="id"><br>
       主人名:<input type="text" name="name"><br>
       宠物号:<input type="text" name="pet.id"><br>
       宠物名:<input type="text" name="pet.name"><br>
       <input type="submit" value="添加主人和宠物">
   </form>
   
   <hr>
   <h1>演示 servlet api的使用 </h1>
   <form action="vote/vote04" method="post">
       用户名:<input type="text" name="username"><br>
       密　码:<input type="password" name="pwd"><br>
       <input type="submit" value="添加用户">
   </form>
   </body>
   </html>
   ```

   ```java
   package com.llq.web.request;
   
   @RequestMapping("/vote")
   @Controller
   public class VoteHandler {
   //获取到超链接传递的数据
       /**
        * 老韩解读@RequestParam(value="name", required=false)
        * 1.@RequestParam : 表示说明一个接受到的参数
        * 2.value="name" : 接收的参数名是name
        * 3.required=false : 表示该参数可以有，也可以没有,如果required=true,表示必须传递该
        * 参数.
        * 默认是required=true
        */
       @RequestMapping(value = "/vote01")
       public String test01(@RequestParam(value = "name", required = false) String username) {
           System.out.println("得到的username= " + username);
               //返回到一个结果
           return "success";
       }
   }
   ```

### 获取 http请求的消息头信息

这其中涉及到 http 协议，可以进行回顾

- Accept-Encoding
- Host

```java
@RequestMapping(value = "/vote02")
public String test02(@RequestHeader("Accept-Encoding") String ae, @RequestHeader("Host") String host) {
    System.out.println("Accept-Encoding =" + ae);
    System.out.println("Host =" + host);
    //返回到一个结果
    return "success";
}
```

###  获取 javabean形式数据

开发中，如何获取到 javabean 的数据，就是以前的 entity/pojo 对象数据

演示将获取到的数据 --> 封装成 Java 对象

1. 方法形参用对应的类型来指定即可 Master【SpringMVC 会自动封装】
2. 如果要自动完成封装，要求提交的数据参数名和对象对应字段名保持一致
3. 如果属性是对象，这里就是仍然通过 字段名.字段名，比如：Master 有一个属性 Pet
   - 即：提交的数据 参数名是：pet.id pet.name，这就是 **级联操作**
4. 如果提交的数据参数和对象的字段名不匹配，则对象的属性值就是 null

```jsp
<hr>
<h1>添加主人信息</h1>
<!--
老韩解读
1. 这是一个表单，表单的数据对应Master对象
2. 提交的数据参数名和对象的字段名一致即可
-->
<form action="vote/vote03" method="post">
    主人号:<input type="text" name="id"><br>
    主人名:<input type="text" name="name"><br>
    宠物号:<input type="text" name="pet.id"><br>
    宠物名:<input type="text" name="pet.name"><br>
    <input type="submit" value="添加主人和宠物">
</form>
```

```java
//获取到添加的主人信息
@RequestMapping(value = "/vote03")
public String test03(Master master) {
    System.out.println("主人信息= " + master);
    //返回结果
    return "success";
}
```

底层仍然是反射 + 注解

### 获取 servlet api

1. 开发中, 我们可能需要使用到原生的servlet api ，看看如何获取
2. 使用servlet api , 需要引入tomcat/lib 下的servlet-api.jar

```jsp
<h1>演示 servlet api的使用 </h1>
<form action="vote/vote04" method="post">
    用户名:<input type="text" name="username"><br>
    密　码:<input type="password" name="pwd"><br>
    <input type="submit" value="添加用户">
</form>
```

```java
@RequestMapping(value = "/vote04")
public String test04(HttpServletRequest request, HttpServletResponse response) {
    System.out.println("name= " + request.getParameter("username"));
    System.out.println("pwd= " + request.getParameter("pwd"));
    //返回结果
    return "success";
}
```

1. 除了HttpServletRequest, HttpServletResponse 还可以其它对象也可以这样的形式获取
2. HttpSession、java.security.Principal,InputStream,OutputStream,Reader,Writer
3. 其中一些对象也可以通过HttpServletRequest / HttpServletResponse 对象获取，比如 Session 对象,既可以通过参数传入，也以通过request.getSession() 获取，效果一样，推 荐使用参数形式传入，更加简单明了

```java
@RequestMapping(value = "/vote04")
public String test04(HttpServletRequest request, HttpServletResponse response, HttpSession hs) { //通过参数传入
    System.out.println("name= " + request.getParameter("username"));
    System.out.println("pwd= " + request.getParameter("pwd"));
    //可以看到 hs 和request.getSession() 是同一个对象
    System.out.println("httpSession=" + httpSession);
    System.out.println("httpSession2=" + request.getSession());
    //返回结果
    return "success";
}
```

## 6. 模型数据【Map、ModelAndView、Session】使用 @ModelAttribute 实现 prepare 方法

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>测试 模型数据</title>
</head>
<body>
<h1>添加主人信息</h1>
<form action="vote/vote05" method="post">
    主人号:<input type="text" name="id"><br>
    主人名:<input type="text" name="name"><br>
    宠物号:<input type="text" name="pet.id"><br>
    宠物名:<input type="text" name="pet.name"><br>
    <input type="submit" value="添加主人和宠物">
</form>

<br/><hr/>
<h1>添加主人信息[测试 Map ]</h1>
<form action="vote/vote06" method="post">
    主人号:<input type="text" name="id"><br>
    主人名:<input type="text" name="name"><br>
    宠物号:<input type="text" name="pet.id"><br>
    宠物名:<input type="text" name="pet.name"><br>
    <input type="submit" value="添加主人和宠物">
</form>

<br/><hr/>
<h1>添加主人信息[测试ModelAndView]</h1>
<form action="vote/vote07" method="post">
    主人号:<input type="text" name="id"><br>
    主人名:<input type="text" name="name"><br>
    宠物号:<input type="text" name="pet.id"><br>
    宠物名:<input type="text" name="pet.name"><br>
    <input type="submit" value="添加主人和宠物">
</form>

<br/><hr/>
<h1>添加主人信息[测试session]</h1>
<form action="vote/vote08" method="post">
    主人号:<input type="text" name="id"><br>
    主人名:<input type="text" name="name"><br>
    宠物号:<input type="text" name="pet.id"><br>
    宠物名:<input type="text" name="pet.name"><br>
    <input type="submit" value="添加主人和宠物">
</form>
</body>
</html>
```

通过请求的方法参数 Map<String, Object> 放入 request 域

```java
@RequestMapping(value = "/vote06")
public String test06(Master master, Map<String, Object> map) {
    //  1. 需求：通过 map 对象，添加属性到 request 域中
    //  2. 原理分析：springmvc 会遍历 map，然后将 map 的 key-value 存放到 request 域中
    map.put("address", "beijing...");
    //返回到一个结果
    return "vote_ok";
}
```

通过返回 ModelAndView对象，实现 request域数据

```java
/**
     * 演示通过 ModelAndView对象，将数据放入到 request域
*/
@RequestMapping(value = "/vote07")
public ModelAndView test07(Master master){
    ModelAndView modelAndView = new ModelAndView();
    //  放入属性到 modelAndView 对象
    modelAndView.addObject("address", "jixi");
    //  指定要跳转的视图名称
    modelAndView.setViewName("vote_ok");
    //  返回结果
    return modelAndView;
}
```

注意事项：

1. 从本质看，请求响应的方法 return "xx", 是返回了一个字符串，其实本质是返回了一个ModelAndView 对象，只是默认被封装起来的
2. ModelAndView 即可以包含model 数据，也可以包含视图信息
3. ModelAndView 对象的addObject 方法可以添加 key-val 数据，默认在request 域中
4. ModelAndView 对象 setView 方法可以指定视图名称

数据放入 Session

开发中, 控制器/处理器中获取的数据如何放入session 域，然后在前端(VUE/JSP/...) 取出显示

```jsp
<h1>添加主人信息[测试session]</h1>
<form action="vote/vote08" method="post">
    主人号:<input type="text" name="id"><br>
    主人名:<input type="text" name="name"><br>
    宠物号:<input type="text" name="pet.id"><br>
    宠物名:<input type="text" name="pet.name"><br>
    <input type="submit" value="添加主人和宠物">
</form>
```

```java
/**
  * 演示如何将数据设置到 session 域中
  * @param master
  * @return
 */
@RequestMapping(value = "/vote08")
public String test08(Master master, HttpSession httpSession){
    //  master 对象默认是放在 request 域中的
    //  现在我们将 master 对象放入 session 中
    httpSession.setAttribute("master", master);
    httpSession.setAttribute("address", "sz");
    return "vote_ok";
}
```

```jsp
<hr>
取出 session域的数据 <br>
address: ${sessionScope.address}<br>
主人名字= ${sessionScope.master.name}
主人信息= ${sessionScope.master}
```

使用 @ModelAttribute 实现 prepare 方法

开发中，有时需要使用某个前置方法(比如prepareXxx() 方法名由程序员定)

给目标方法准备一个模型对象

1. @ModelAttribute 注解可以实现这样的需求
2. 在某个方法上，增加了@ModelAttribute 注解后
3. 那么在调用该Handler 的任何一个方法时，都会先调用这个方法

```java
/**
     * 解读
     * 1. 当 Handler 的方法被标识了 @ModelAttribute，该方法就视为一个前置方法
     * 2. 当调用该 Handler 的其它方法时，都会先执行该前置方法
     * 3. 类似前面讲解 Spring 的 AOP 前置通知【底层是 AOP 机制】
     * 4. preparedModel()前置方法，会切入到其它方法前执行...
     */
@ModelAttribute
public void preparedModel(){
    System.out.println("prepareModel()-- 完成准备工作-- ");
}
```

最佳实践：

修改用户信息（就是经典的使用这种机制的应用），流程如下:

1. 在修改前，在前置方法中从数据库查出这个用户
2. 在修改方法(目标方法)中，可以使用前置方法从数据库查询的用户
3. 如果表单中对用户的某个属性修改了，则以新的数据为准，如果没有修改，则以数据库的信息为准，比如，用户的某个属性不能修改，就保持原来的值

## 7. 视图解析器

基本介绍

1. 在springMVC 中的目标方法最终返回都是一个视图【有各种视图】
2. 返回的视图都会由一个视图解析器来处理【视图解析器有很多种】

自定义视图

1. 在默认情况下，我们都是返回默认的视图, 然后这个返回的视图交由SpringMVC 的 InternalResourceViewResolver 视图处理器来处理

   ```xml
   <!-- 配置视图解析器 -->
   <!-- 在整个容器中，只会有一个视图解析器 -->
   <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
       <!-- 配置属性 suffix 和 prefix -->
       <property name="prefix" value="/WEB-INF/pages/"/>
       <property name="suffix" value=".jsp"/>
   </bean>
   ```

2. 在实际开发中，我们有时需要自定义视图,这样可以满足更多更复杂的需求【注意：自定义视图是一个类，当运行起来后，是一个对象】

   ```java
   package com.llq.web.viewresolver;
   
   /**
    * 老师解读
    * 1. MyView继承了AbstractView, 就可以作为一个视图使用
    * 2. @Component(value = "myView"),该视图会注入到容器中, 名字/id是 myView
    */
   @Component(value = "hspView")
   public class MyView extends AbstractView {
       @Override
       protected void renderMergedOutputModel(Map<String, Object> model,
                                              HttpServletRequest request,
                                              HttpServletResponse response) throws Exception {
   
           //完成视图渲染
           //并且可以确定我们要跳转的页面 [请求转发] /WEB-INF/pages/my_view.jsp
           System.out.println("进入到自己的视图..");
   
           //老师解读
           //1. 下面就是进行请求转发到 /WEB-INF/pages/my_view.jsp
           //2. /WEB-INF/pages/my_view.jsp 会被springmvc解析
           //   /springmvc/WEB-INF/pages/my_view.jsp
           request.getRequestDispatcher("/WEB-INF/pages/my_view.jsp")
                   .forward(request, response);
       }
   }
   ```

   配置自定义视图解析器

   ```xml
   <!--
           1. 配置自定义视图解析器 BeanNameViewResolver
           2. BeanNameViewResolver 可以去解析我们自定义的视图
           3. 配置 属性 order：表示视图解析器执行的顺序
           4. 属性 order 的默认值是最低优先级：值为：Integer.MAX_VALUE
       -->
   <bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
       <property name="order" value="99"/>
   </bean>
   ```

   自定义视图小结：

   1. 自定义视图: 创建一个View 的bean, 该bean 需要继承自AbstractView, 并实现 renderMergedOutputModel 方法
   2. 并把自定义View 加入到 IOC 容器中
   3. 自定义视图的视图处理器，使用BeanNameViewResolver， 这个视图处理器也需要配置到ioc 容器
   4. BeanNameViewResolver 的调用优先级需要设置一下，设置order 比Integer.MAX_VAL小的值. 以确保其在InternalResourceViewResolver 之前被调用

   自定义视图工作流程：

   1. SpringMVC 调用目标方法, 返回自定义View 在IOC 容器中的id
   2. SpringMVC 调用BeanNameViewResolver 解析视图: 从IOC 容器中获取返回id 值对应的bean, 即自定义的View 的对象
   3. SpringMVC 调用自定义视图的renderMergedOutputModel 方法渲染视图
   4. 老韩说明: 如果在SpringMVC 调用目标方法, 返回自定义View 在IOC 容器中的id,不存在， 则仍然按照默认的视图处理器机制处理.

## 8. 数据格式化

说明: 在我们提交数据(比如表单时)SpringMVC 怎样对提交的数据进行转换和处理的

比如:Spring MVC 上下文中内建了很多 <font color="yellow">**转换器**</font>，可完成大多数Java 类型的转换工作。[相互转换，这里只列出部分]

| 转换器 ConversionService converters=                         | 实现功能              |
| ------------------------------------------------------------ | --------------------- |
| java.lang.Boolean -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@f874ca | Boolean --> String    |
| java.lang.Character -> java.lang.Number : CharacterToNumberFactory@f004c9 | Character --> Number  |
| java.lang.Character -> java.lang.String : ObjectToStringConverter@68a961 | Character --> String  |
| java.lang.Enum -> java.lang.String : EnumToStringConverter@12f060a | Enum --> String       |
| java.lang.Number -> java.lang.Character : NumberToCharacterConverter@1482ac5 | Number --> Character  |
| java.lang.Number -> java.lang.Number : NumberToNumberConverterFactory@126c6f | Number --> Number     |
| java.lang.Number -> java.lang.String : ObjectToStringConverter@14888e8 | Number --> String     |
| java.lang.String -> java.lang.Boolean : StringToBooleanConverter@1ca6626 | String --> Boolean    |
| java.lang.String -> java.lang.Character : StringToCharacterConverter@1143800 | String --> Character  |
| java.lang.String -> java.lang.Enum : StringToEnumConverterFactory@1bba86e | String --> Enum       |
| java.lang.String -> java.lang.Number : StringToNumberConverterFactory@18d2c12 | String --> Number     |
| java.lang.String -> java.util.Locale : StringToLocaleConverter@3598e1 | String --> Locale     |
| java.lang.String -> java.util.Properties : StringToPropertiesConverter@c90828 | String --> Properties |
| java.lang.String -> java.util.UUID : StringToUUIDConverter@a42f23 | String --> UUID       |
| java.util.Locale -> java.lang.String : ObjectToStringConverter@c7e20a | Locale --> String     |
| java.util.Properties -> java.lang.String : PropertiesToStringConverter@367a7f | Properties --> String |
| java.util.UUID -> java.lang.String : ObjectToStringConverter@112b07f | UUID --> String       |

### 基本数组类型 <===> 字符串

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>SpringMVC[数据格式/验证等]</title>
    <script type="text/javascript" src="script/jquery-3.6.0.min.js"></script>
    <base href="<%=request.getContextPath() + "/"%>">
</head>
<body>
<h1>SpringMVC[数据格式/验证等]</h1>
<hr>
<a href="addMonsterUI" id="addMonsterUI">添加妖怪</a>
</body>
</body>
</html>
```

```java
package com.llq.web.datavalid;
/**
 * MonsterHandler 处理器：响应用户提交数据
 * prototype：每次请求 MonsterHandler 会生成一个新的 MonsterHandler 对象
 */
@Controller
@Scope(value = "prototype") //  多例
public class MonsterHandler {
    @RequestMapping(value = "/addMonsterUI")
    //  当我们向 map 放入数据时，会默认放到 request域中
    public String addMonsterUI(Map<String, Object> map){
        //注意观察输出内容
        //  注意：
        //  1. 如果你跳转的页面使用 SpringMVC 标签
        //  2. 就需要准备一个对象，放入 request 域中
        //  3. 这个对象的属性名是 monster
        //  4. 要对应 SpringMVC表单标签：modelAttribute="monster"
        map.put("monster", new Monster());
        return "datavalid/monster_addUI";
    }
}
```

引入 Spring MVC 特定的标签：`<form:form>` 标签

需要在 JSP 页面中使用 Spring 的标签库（`<%@ taglib %>`）导入相关的命名空间。

```jsp
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
```

```jsp
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <base href="<%=request.getContextPath() + "/"%>"> <!-- Base 标签-->
</head>
<body>
<h3>添加妖怪~~</h3>
<!-- 这里的表单，我们使用springMVC 的标签来完成
特别说明几点:
1. SpringMVC 表单标签在显示之前必须在request 中有一个bean, 该bean 的属性
和表单标签的字段要对应!
request 中的key 为: form 标签的modelAttrite 属性值， 比如这里的monsters
2. SpringMVC 的form:form 标签的action 属性值中的/ 不代表WEB 应用的根目录.
3. 这里使用 SpringMVC的标签的主要目的是：方便提示信息的回显
-->
<form:form action="save" method="POST" modelAttribute="monster">
    妖怪名字: <form:input path="name"/> <br><br>
    妖怪年龄~: <form:input path="age"/> <br><br>
    电子邮件: <form:input path="email"/> <br><br>
    <input type="submit" value="添加妖怪"/>
</form:form>
</body>
</html>
```

`<form:form>` 是 Spring MVC 中的标签，用于生成 HTML 表单。

`<form:form>` 标签用于绑定模型对象（`modelAttribute`）到表单，并指定表单的 action 和 method。它会生成一个包含表单字段的 HTML 表单，并将表单提交到指定的 action。

在你提供的示例代码中，`<form:form>` 标签用于生成一个包含三个输入字段（妖怪名字、妖怪年龄、电子邮件）和一个提交按钮的表单。

其中，`modelAttribute="monster"` 指定了模型对象的属性名为 "monster"，即模型对象的属性将与表单字段进行绑定。

`<form:input>` 标签用于生成表单的输入字段，其中 `path` 属性指定了字段与模型对象属性的关联关系。

在表单提交时，用户输入的值将通过表单字段的名称和模型对象的属性名进行绑定，从而在后端控制器中获取表单数据。

需要注意的是，`<form:form>` 标签是 Spring MVC 特定的标签，需要在 JSP 页面中使用 Spring 的标签库（`<%@ taglib %>`）导入相关的命名空间。

编写方法，处理添加妖怪

```java
//  编写方法，处理添加妖怪
@RequestMapping(value = "/save")
public String saveMonster(Monster monster){
    System.out.println("monster= " + monster);
    return "datavalid/success";
}
```

此时，无法将 String（fe） ---> Integer：就会报错：400【客户端错误】

### 特殊数据类型【Date、salary等】 <===> 字符串

特殊数据类型和字符串之间的转换使用注解【比如：**日期**，规定格式的小数比如 **货币形式**等】

- 日期：@DataTimeFormat
- 货币：@NumberFormat

修改 Monster.java，增加 birthday 和 salary 字段

```java
@DateTimeFormat(pattern="yyyy-MM-dd")
private Date birthday;
@NumberFormat(pattern="###,###.##")	//	逗号：间隔
private float salary;
```

修改 monster_addUI，增加 birthday 和 salary 字段

```jsp
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <base href="<%=request.getContextPath() + "/"%>">
</head>
<body>
<h3>添加妖怪~~</h3>
<form:form action="save" method="POST" modelAttribute="monster">
    妖怪名字: <form:input path="name"/> <br><br>	<!-- 注意path 与 属性名一致 -->
    妖怪年龄~: <form:input path="age"/> <br><br>
    妖怪生日: <form:input path="birthday"/>要求以"9999-11-11"的形式 <br><br>
    妖怪工资：<form:input path="salary"/>要求以"123,890,12"的形式 <br><br>
    电子邮件: <form:input path="email"/> <br><br>
    <input type="submit" value="添加妖怪"/>
</form:form>
</body>
</html>
```

如果没有按照注解指定格式，则给出400 的页面【typeMismatch】

### 验证与国际化

#### 1. 概述【验证、并给出提示信息：通过注解】

1. 对输入的数据(比如表单数据)，进行必要的验证，并给出相应的提示信息。
2. 对于验证表单数据，springMVC 提供了很多实用的注解, 这些注解由JSR 303 验证框架提供.

#### 2. JSR 303 验证框架

1. JSR 303 是Java 为 **Bean** **数据合法性校验** 提供的标准框架，它已经包含在JavaEE 中
2. JSR 303 通过在Bean 属性上标注类似于@NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean 进行验证
3. JSR 303 提供的基本验证注解有

#### 3. Hibernate Validator 扩展注释

1. Hibernate Validator 和Hibernate 没有关系，只是JSR 303 实现的一个扩展.

2. Hibernate Validator 是JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支 持以下的扩展注解:

   ```bash
   # @Email
   # @Length
   # @NotEmpty
   # @Range
   ```

测试：

```java
package com.llq.web.datavalid.entity;

public class Monster {
    private Integer id;
    private String email;
    @Range(min = 1, max = 100)
    private Integer age;
    @NotEmpty
    private String name;
    @DateTimeFormat(pattern="yyyy-MM-dd")
    private Date birthday;
    @NumberFormat(pattern="###,###.##")
    private float salary;
}
```

使用 <font color="yellow">@Valid 注解 </font>使得验证生效

```java
/**
     * @Valid Monster monster：表示对 monster接受的数据进行校验
     * @param errors：如果校验出现错误，将校验的错误信息保存在 errors 中
     * @param map：如果校验出现错误，将校验错误信息保存在 map，同时保存 monster 对象
     * @ 校验发生时机：在 SpringMVC 反射调用目标方法时，会接收到 http 请求的数据，然后根据注解来进行验证
     *   如果出现了错误，就把错误信息填充到 errors 和 map
*/
@RequestMapping(value = "/save")
public String saveMonster(@Valid Monster monster, Errors errors, Map<String, Object> map){
    System.out.println("monster= " + monster);
    System.out.println("=============map=============");
    for (String s : map.keySet()) {
        System.out.println(s + "====" + map.get(s));
    }
    System.out.println("===========errors=============");
    List<ObjectError> allErrors = errors.getAllErrors();
    System.out.println(allErrors);

    return "datavalid/success";
}
```

回显错误标签：

```java
@RequestMapping(value = "/save")
public String saveMonster(@Valid Monster monster, Errors errors, Map<String, Object> map){
    System.out.println("monster= " + monster);
    System.out.println("=============map=============");
    for (String s : map.keySet()) {
        System.out.println(s + "====" + map.get(s));
    }
    System.out.println("===========errors=============");
    List<ObjectError> allErrors = errors.getAllErrors();
    for (ObjectError allError : allErrors) {
        System.out.println(allError);
    }
    if (!allErrors.isEmpty()){	//	有错误信息的话，跳转回添加界面
        return "datavalid/monster_addUI";
    }
    return "datavalid/success";
}
```

```jsp
<form:form action="save" method="POST" modelAttribute="monster">
    妖怪名字: <form:input path="name"/><form:errors path="name"/> <br><br>
    妖怪年龄~: <form:input path="age"/><form:errors path="age"/>  <br><br>
    妖怪生日: <form:input path="birthday"/><form:errors path="birthday"/> 要求以"9999-11-11"的形式 <br><br>
    妖怪工资：<form:input path="salary"/><form:errors path="salary"/> 要求以"123,890,12"的形式 <br><br>
    电子邮件: <form:input path="email"/><form:errors path="email"/>  <br><br>
    <input type="submit" value="添加妖怪"/>
</form:form>
</body>
</html>
```

但是现在不太好看，我们可以自定义错误信息

在 Spring配置文件中，配置国际化错误信息的资源处理

```xml
<!-- 配置国际化错误信息的资源处理bean -->
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
    <!-- 配置国际化文件名字
         如果你这样配的话，表示messageSource 会到src/i18nXXX.properties 去读取错误信息
        -->
    <property name="basename" value="i18n"></property>
</bean>
```

```properties
NotEmpty.monster.name=\u7528\u6237\u540d\u4e0d\u80fd\u4e3a\u7a7a
typeMismatch.monster.age=\u5e74\u9f84\u8981\u6c42\u5728\u0031\u002d\u0031\u0035\u0030\u4e4b\u95f4
typeMismatch.monster.birthday=\u751f\u65e5\u683c\u5f0f\u4e0d\u6b63\u786e
typeMismatch.monster.salary=\u85aa\u6c34\u683c\u5f0f\u4e0d\u6b63\u786e
```

这里使用 Unicode 节码工具

```bash
# 年龄要求在1-150之间
\u5e74\u9f84\u8981\u6c42\u57281-150\u4e4b\u95f4
```

注意细节

1. 在需要验证的Javabean/POJO 的字段上加上相应的验证注解.

2. 目标方法上,在JavaBean/POJO 类型的参数前, 添加@Valid 注解. 告知SpringMVC 该bean 是需要验证的

3. 在@Valid 注解之后, 添加一个Errors 或BindingResult 类型的参数, 可以获取到验证 的错误信息

4. 需要使用<form:errors path="email"></form:errors> 标签来显示错误消息, 这个标签， 需要写在form:form 标签内生效.

5. 错误消息的国际化文件i18n.properties , 中文需要是Unicode 编码，使用工具转码. 

   - 格式: 验证规则.表单modelAttribute 值.属性名=消息信息 √
     - NotEmpty.monster.name=\u540D\u5B57\u4E0D\u80FD\u4E3A\u7A7A
     - typeMismatch.monster.age=\u7C7B\u578B\u4E0D\u5339\u914D

6. 注解 @NotNull 和 @NotEmpty 的区别说明

   - 查看源码可以知道: @NotEmpty Asserts that the annotated string, collection, map or array is not {@code null} or empty

   - 查看源码可以知道: @NotNull * The annotated element must not be {@code null}.* Accepts any type.

     ​	解读：如果是字符串验证为空，建议使用 @NotEmpty

7. SpringMVC 验证时，会根据不同的验证错误，返回对应的信息

#### 4. 注解的结合使用

看一个问题：age没有，是空的，提交确成功了

使用组合注解

- @NotNull
- @Range

```java
@NotNull(message = "age不能为 null")
@Range(min = 1, max = 100)
private Integer age;
```

#### 5. 数据类型转换校验核心类：DataBinder

#### 6. 取消某个属性的绑定【@InitBinder】

在默认情况下，表单提交的数据都会和pojo 类型的javabean 属性绑定，如果程序员在开发中，希望取消某个属性的绑定，也就是说：

不希望接收到某个表单对应的属性的值，则可以通过@InitBinder 注解取消绑定

1. 编写一个方法, 使用@InitBinder 标识的该方法，可以对WebDataBinder 对象进行初始化。WebDataBinder 是DataBinder 的子类，用于完成由表单字段到JavaBean 属性的绑定
2. @InitBinder 方法不能有返回值，它必须声明为void
3. @InitBinder 方法的参数通常是是WebDataBinder

案例：不接收怪物的名字属性

```java
//  取消绑定 monster 的name 表单提交的值 给 monster.name 属性
//  底层：SpringMVC 通过反射调用目标方法时，接收到 http 请求的参数和值，使用反射 + 注解机制
//  取消对指定属性的填充
//  setDisallowedFields 支持可变参数，可以填写多个字段
//  如果取消了某个属性绑定，验证就没有意义了，应当把验证的注解拿掉，name属性会使用默认值 null
@InitBinder
public void initBinder(WebDataBinder webDataBinder){
    webDataBinder.setDisallowedFields("name");
}
```

### 中文乱码处理

#### 1. 自定义中文乱码过滤器【Filter的 doFilter(request, response) 方法】

当表单提交数据为中文时，会出现乱码

回顾 JavaWeb 中的 Filter 机制

- 根据 request 对象封装的到 uri filterUrlMapping 获取 filter-name
- 根据 filter-name 到 LlqFilter，获取 LlqFilter 对象【实现 Filter 接口】
  - 获取到了，调用 doFilter() 方法【动态绑定】
  - 没有匹配到，就直接走我们后面的 servlet/jsp/html

```java
public class MyCharacterFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("utf-8");
        //  放行请求
        filterChain.doFilter(servletRequest, servletResponse);
    }
    @Override
    public void destroy() {

    }
}
```

在 Web.xml 中配置 url-pattern 规则

```xml
<!--配置处理中文乱码的过滤器
	拦截所有请求：处理编码
 -->
<filter>
    <filter-name>MyCharacterFilter</filter-name>
    <filter-class>com.llq.web.filter.MyCharacterFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>MyCharacterFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

#### 2. Spring提供的过滤器处理中文

如果自己设定编码的话，编码是写死成 utf-8 的

```java
request.setCharacterEncoding("utf-8");   
response.setContentType("text/html;charset=utf-8");
```

不太灵活

所以我们使用 Spring 给我们提供的过滤器

```xml
<!-- 配置 Spring提供的过滤器，解决中文乱码问题 -->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>utf-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

### 处理 json 和 HttpMessageConverter\<T>【引入处理json 需要的jar 包，注意spring5.x 需要使用jackson-2.9.x.jar 的包.】

项目开发中，我们往往需要服务器返回的数据格式是按照json 来返回的

#### 1. 处理 JSON：@ResponseBody【作用于方法】

我们的 ajax 引擎对象 xhr 和后台在通讯的时候，它会不停地看 xhr 对象有没有变化，通过 readyState来观察获取到哪一个阶段的数据了

每当 xhr 对象的 readyState 改变 时，就会触发 onreadystatechange 事件

readyState 保存 XMLHttpRequest 的状态

- 0：请求未初始化
- 1：服务器连接已建立
- 2：请求已收到
- 3：正在处理请求
- 4：请求已完成且响应已就绪

```java
@Controller
public class JsonHandler {
    @RequestMapping(value = "/json/dog")
    //  目标方法加上 @ResponseBody，表示返回的数据是 json 格式
    //  SpringMVC 底层根据目标方法 @ResponseBody，返回指定格式，根据 http 请求来进行处理
    //  底层原理在前面自定义注解时说过。这里远程的 SpringMVC 使用了转换器
    //  HttpMethodConverter【一会儿 Debug】
    @ResponseBody
    public Dog getJson(){
        //  返回对象：
        //  SpringMVC 会根据你的设置，转成 JSON 格式数据
        Dog dog = new Dog();
        dog.setName("小黄");
        dog.setAddress("大菠萝");
        return dog;
    }
}
```

#### 2. 处理 JSON：@RequestBody【作用于形参】

1. 使用SpringMVC 的@RequestBody 将客户端提交的json 数据，封装成JavaBean 对象
2. 再把这个javabean 以json 对象形式返回

```java
@PostMapping("/save2")
@ResponseBody
//	在形参指定 @RequestBody 注解，SpringMVC 将提交的 json 字符串数据，填充给指定的 JavaBean
public User save2(@RequestBody User user){	
    System.out.println("user =" + user);
    return user;
}
```

#### 3. 注意事项和细节

1. 目标方法正常返回JSON 需要的数据, 可以是一个对象, 也可以是一个集合
2. @ResponseBody 可以直接写在controller 上，这样对所有方法生效
3. @ResponseBody + @Controller 可以直接写成 <font color="yellow">@RestController</font> , 我们看一下源码!

```java
package org.springframework.web.bind.annotation;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 * @since 4.0.1
	 */
	@AliasFor(annotation = Controller.class)
	String value() default "";
}
```

#### 4. HttpMessageConverter\<T>

SpringMVC 处理JSON-底层实现是依靠HttpMessageConverter<T>来进行转换的

```java
contentType: "application/json;charset=utf-8" //  指定发送数据的格式
data_type: "json"   //  要求服务器返回的数据格式为：json
```

### 文件下载：ResponseEntity\<T>

在SpringMVC 中，通过返回 ResponseEntity\<T> 的类型，可以实现文件下载的功能

大体思路

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202310021949242.png)

文件下载响应头的设置：

- content-type：响应内容的格式
- content-disposition：如恶化处理响应内容，一般有2 种类：
  - inline：直接在页面显示
  - attchment：以 **附件形式** 下载

```java
@PostMapping(value = "/downFile")
public ResponseEntity<byte[]> downFile(HttpSession httpSession) throws Exception{
    //  1. 先获得要下载文件的 InputStream
    InputStream resourceAsStream = httpSession.getServletContext().getResourceAsStream("/img/wind.jpg");
    //  2. 开辟一个存放文件的 byte 数组【支持二进制文件的下载】
    byte[] bytes = new byte[resourceAsStream.available()];
    //  3. 将要下载文件的数据，读入到 byte[] 数组
    resourceAsStream.read(bytes);
    // public ResponseEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers, HttpStatus status) {
    // 		this(body, headers, (Object) status);
    // 	}
    //  4. 创建返回的 HttpStatus
    HttpStatus status = HttpStatus.OK;
    //  5. 创建 headers
    HttpHeaders httpHeaders = new HttpHeaders();
    //  指定返回的数据，客户端应该以附件形式处理
    httpHeaders.add("Content-Disposition", "attachment;filename=wind.jpg");
    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, httpHeaders, status);
    return responseEntity;
}
```

```jsp
<h1>下载文件的测试</h1>
<a href="downFile">点击下载文件</a>
```

### 文件上传 CommonsMultipartResovler

1. Spring MVC 为文件上传提供了直接的支持， 这种支持是通过即插即用的MultipartResolver 实现的。Spring 用Jakarta Commons FileUpload 技术实现了一个MultipartResolver 实现类：CommonsMultipartResovler
2. Spring MVC 上下文中默认没有装配MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用Spring 的文件上传功能，需现在上下文中配置 <font color="yellow">MultipartResolver</font>

```bash
# spingmvc上传文件需要的jar
├─ commons-fileupload-1.3.1.jar
└─ commons-io-2.2.jar
```

```xml
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>文件上传</title>
    <base href="<%=request.getContextPath() + "/"%>">
</head>
<body>
<h1>文件上传的演示</h1>
<form action="fileUpload" method="post" enctype="multipart/form-data">
    文件介绍:<input type="text" name="introduce"><br>
    选择文件:<input type="file" name="file"><br>
    <input type="submit" value="上传文件">
</form>
</body>
</html>
```

配置中文过滤器【Filter】，在 web.xml，使用 Spring提供的，我们前面已经配置过了

配置文件上传解析器，在 applicationContext-mvc.xml【Spring 配置文件】 中配置CommonsMultipartResolver 源码【有了它才能够实现文件上传处理】

```xml
<!-- 配置文件上传解析器
	底层是按照接口 来进行装配的
-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>
```

应用实现：

```java
@Controller
public class FileUploadHandler {
    //  编写方法，处理文件上传的请求
    @RequestMapping(value = "/fileUpload")
    public String fileUpload(@RequestParam(value = "file") MultipartFile multipartFile, HttpServletRequest request) throws IOException {
        String filename = multipartFile.getOriginalFilename();
        System.out.println("你上传的文件名：" + filename);
        //  得到要把上传文件保存到哪个路径
        String fileFullPath = request.getServletContext().getRealPath("/img/" + filename);  //  真实路径
        //  创建文件
        File saveToFile = new File(fileFullPath);
        //  将上传的文件转存到 saveToFile
        multipartFile.transferTo(saveToFile);
        return "success";
    }
}
```

我们还可以轻松地获取 jsp 提交的 introduce 字段

```java
@Controller
public class FileUploadHandler {
    //  编写方法，处理文件上传的请求
    @RequestMapping(value = "/fileUpload")
    public String fileUpload(@RequestParam(value = "file") MultipartFile multipartFile, HttpServletRequest request, String introduce) throws IOException {
        String filename = multipartFile.getOriginalFilename();
        System.out.println("你上传的文件名：" + filename);
        //  得到要把上传文件保存到哪个路径
        String fileFullPath = request.getServletContext().getRealPath("/img/" + filename);  //  真实路径
        //  创建文件
        File saveToFile = new File(fileFullPath);
        //  将上传的文件转存到 saveToFile
        multipartFile.transferTo(saveToFile);
        System.out.println("文件介绍为：" + introduce);
        return "success";
    }
}
```

分析下：

```java
//  将上传的文件转存到 saveToFile
multipartFile.transferTo(saveToFile);
```

```java
@Override
public void transferTo(File dest) throws IOException, IllegalStateException {
    if (!isAvailable()) {
        throw new IllegalStateException("File has already been moved - cannot be transferred again");
    }

    if (dest.exists() && !dest.delete()) {
        throw new IOException(
            "Destination file [" + dest.getAbsolutePath() + "] already exists and could not be deleted");
    }

    try {
        this.fileItem.write(dest);	//	底层和 用 JavaWeb 实现文件上传一致！！！
        LogFormatUtils.traceDebug(logger, traceOn -> {
            String action = "transferred";
            if (!this.fileItem.isInMemory()) {
                action = (isAvailable() ? "copied" : "moved");
            }
            return "Part '" + getName() + "',  filename '" + getOriginalFilename() + "'" +
                (traceOn ? ", stored " + getStorageDescription() : "") +
                ": " + action + " to [" + dest.getAbsolutePath() + "]";
        });
    }
    catch (FileUploadException ex) {
        throw new IllegalStateException(ex.getMessage(), ex);
    }
    catch (IllegalStateException | IOException ex) {
        // Pass through IllegalStateException when coming from FileItem directly,
        // or propagate an exception from I/O operations within FileItem.write
        throw ex;
    }
    catch (Exception ex) {
        throw new IOException("File transfer failed", ex);
    }
}
```

### 自定义拦截器【实现 HandlerInterceptor 接口】

1. Spring MVC 也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能.
2. 自定义的拦截器必须实现HandlerInterceptor 接口

自定义拦截器的三个方法：

1. **pre**Handle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求request 进行处理。
2. **post**Handle()：这个方法在目标方法处理完请求后执行
3. **after**Completion()：这个方法在完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作

#### 自定义拦截器执行流程分析图

![image-20231004121813276](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202310041218393.png)

自定义拦截器执行流程说明

1. 如果preHandle 方法返回false, 则不再执行目标方法, 可以在此指定返回页面
2. postHandle 在目标方法被执行后执行. 可以在方法中访问到目标方法返回的ModelAndView 对象
3. 若preHandle 返回true, 则afterCompletion 方法在渲染视图之后被执行.
4. 若preHandle 返回false, 则afterCompletion 方法不会被调用
5. 在配置拦截器时，可以指定该拦截器对哪些请求生效，哪些请求不生效

#### 自定义拦截器应用实例

完成一个自定义拦截器，学习一下如何配置拦截器和拦截器的运行流程

```java
package com.llq.web.interceptor;

@Component
public class MyInterceptor01 implements HandlerInterceptor {

    /**
     * 1. preHandle() 在目标方法执行前被执行
     * 2. 如果 preHandle() 返回 false，那么目标方法就不再被执行【可以指定跳转到哪个页面】
     * 3. 该方法可以获得如下信息
     * @param request
     * @param response
     * @param handler：目标处理器
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("--MyInterceptor01--preHandle 被执行了");
        return true;
    }

    /**
     * 1. 在目标方法执行后，会执行 postHandle
     * 2. 该方法可以获取到 目标方法返回的 ModelAndView对象
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyInterceptor01--postHandle");
    }

    /**
     * 1. 在视图选然后被执行，这里可以进行资源清理工作
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyInterceptor01--afterCompletion");
    }
}
```

```java
package com.llq.web.interceptor;

@Controller
public class FurnHandler {

    @RequestMapping(value = "/hi")
    public String hi(){
        System.out.println("FurnHandler--hi()---");
        return "success";
    }

    @RequestMapping(value = "/hello")
    public String hello(){
        System.out.println("FurnHandler--hello()---");
        return "success";
    }
}
```

##### ref 应用对应的拦截器（拦截所有的方法）

```xml
<!--配置自定义拦截器 Spring配置文件-->
<mvc:interceptors>
    <!--第一种方式
            直接使用 ref 引用到对应的 myInterceptor01
            这种方式会拦截所有的目标方法
        -->
    <ref bean="myInterceptor01"/>
</mvc:interceptors>
```

##### 指定拦截的路径 path

默认配置都是对所有的目标方法都进行拦截，也可以指定拦截目标方法，比如：只是拦截 hi

```xml
<!--配置自定义拦截器 Spring配置文件-->
<mvc:interceptors>
    <!-- 第二种配置方式
            1. path：指定要拦截的路径
            2. ref：指定哪一个拦截器
        -->
    <mvc:interceptor>
        <mvc:mapping path="/hi"/>
        <ref bean="myInterceptor01"/>
    </mvc:interceptor>
</mvc:interceptors>
```

##### 指定通配符

注意：mvc:mapping 支持通配符，同时指定不对哪些目标方法进行拦截

```xml
<mvc:interceptor>
    <mvc:mapping path="/h*"/>
    <mvc:exclude-mapping path="/hello"/>
    <ref bean="myInterceptor01"/>
</mvc:interceptor>
```

拦截器需要配置才生效，不配置是不生效的.

如果preHandler() 方法返回了false, 就不会执行目标方法(前提是 **你的目标方法被拦截** 了), 程序员可以在这里根据业务需要指定跳转页面.

#### 多个拦截器

多个拦截器执行流程示意图

![image-20231004130522552](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202310041305710.png)

测试 2个拦截器（按照配置的顺序执行）

```xml
<!--配置自定义拦截器 Spring配置文件-->
<mvc:interceptors>
    <!-- 第二种配置方式
            1. path：指定要拦截的路径
            2. ref：指定哪一个拦截器
        -->
    <mvc:interceptor>
        <mvc:mapping path="/h*"/>
        <mvc:exclude-mapping path="/hello"/>
        <ref bean="myInterceptor01"/>
    </mvc:interceptor>

    <mvc:interceptor>
        <mvc:mapping path="/h*"/>
        <ref bean="myInterceptor02"/>
    </mvc:interceptor>

</mvc:interceptors>
```

注意事项和细节：

1. 如果第1 个拦截器的preHandle() 返回false , 后面都不在执行
2. 如果第2 个拦截器的preHandle() 返回false , 就直接执行第1 个拦截器的afterCompletion()方法, 如果拦截器更多，规则类似
3. 说明: 前面说的规则，都是目标方法被拦截的前提

应用：如果带有病毒的话，就拦截，并回复 ”不要乱讲话"

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    System.out.println("--MyInterceptor01--preHandle 被执行了");
    String keyword = request.getParameter("keyword");
    if ("病毒".equals(keyword)){
        request.getRequestDispatcher("/WEB-INF/pages/warming.jsp").forward(request, response);
        return false;
    }
    System.out.println("得到 keyword" + keyword);
    return true;
}
```

### 9. 异常处理【通过 HandlerExceptionResolver 处理程序异常】

![image-20231004165427400](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202310041654526.png)

基本介绍：

1. Spring MVC 通过HandlerExceptionResolver 处理程序的异常，包括Handler 映射、数据绑定以及目标方法执行时发生的异常。
2. 主要处理Handler 中用 @**ExceptionHandler** 注解定义的方法。
3. ExceptionHandlerMethodResolver 内部若找不到@ExceptionHandler 注解的话， 会找 @**ControllerAdvice** 类的@ExceptionHandler 注解方法, 这样就相当于一个全局异常处理器

#### 局部异常

如果你不去处理的话，那么这个异常就由 Tomcat去处理的，非常不友好

```java
@Controller
public class MyExceptionHandler {
    //  编写方法，模拟异常
    @RequestMapping(value = "/testException01")
    public String test01(Integer num){
        int i = 9 / num;
        return "success";
    }
}
```

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>异常信息</title>
    <base href="<%=request.getContextPath() + "/"%>">
</head>
<body>
<h1>测试异常</h1>
<a href="testException01?num=0">异常测试</a>
</body>
</html>
```

解决方式：按照局部异常解决，在 Handler 中新增一个方法

```java
/**
     * 1. 处理局部异常
     * 2. 这里处理 ArithmeticException.class, NullPointerException.class 异常
     * 3. Exception e：生成的异常对象，会传递给 e，通过 e 可以得到异常相关信息
     * @return
     */
@ExceptionHandler({ArithmeticException.class, NullPointerException.class})
public String localException(Exception e, HttpServletRequest request){
    System.out.println("局部异常信息是~" + e.getMessage());
    request.setAttribute("reason", e.getMessage());
    return "exception_mes";
}
```

#### 全局异常

ExceptionHandlerMethodResolver 内部若找不到@ExceptionHandler 注解的话， 会找 @**ControllerAdvice** 类的@ExceptionHandler 注解方法, 这样就相当于一个全局异常处理器

```java
package com.llq.web.exception;

//  如果类上标注了 @ControllerAdvice，就是一个全局异常处理类
@ControllerAdvice
public class MyGlobalException {
    //  全局异常不管是哪个 Handler 抛出的异常，都可以捕获，@ExceptionHandler（{异常类型}）
    @ExceptionHandler({NumberFormatException.class, ClassCastException.class})
    public String globalException(Exception e, HttpServletRequest request){
        System.out.println("全局异常处理~ " + e.getMessage());
        request.setAttribute("reason", e.getMessage());
        return "exception_mes";
    }
}
```

我们模拟了一个异常 NumberFormatException

该异常没有在局部异常处理中处理，按照异常处理机制，就会交给 <font color="yellow">**全局异常处理类[@ControllerAdvice]** </font>处理

```java
package com.llq.web.exception;

//  如果类上标注了 @ControllerAdvice，就是一个全局异常处理类
@ControllerAdvice
public class MyGlobalException {
    //  全局异常不管是哪个 Handler 抛出的异常，都可以捕获，@ExceptionHandler（{异常类型}）
    @ExceptionHandler({NumberFormatException.class, ClassCastException.class})
    public String globalException(Exception e, HttpServletRequest request){
        System.out.println("全局异常处理~ " + e.getMessage());
        request.setAttribute("reason", e.getMessage());
        return "exception_mes";
    }
}
```

我们模拟了一个异常 NumberFormatException

该异常没有在局部异常处理中处理，按照异常处理机制，就会交给 <font color="yellow">**全局异常处理类[@ControllerAdvice]**</font> 处理

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>异常信息</title>
    <base href="<%=request.getContextPath() + "/"%>">
</head>
<body>
<h1>测试异常</h1>
<a href="testException01?num=dwr">异常测试</a>
</body>
</html>
```

细节：异常处理时，局部异常高于全局异常

#### 自定义异常

通过@ResponseStatus 注解, 可以自定义异常的说明

```java
package com.llq.web.exception;

@ResponseStatus(reason = " 年龄在 1- 120 之间", value = HttpStatus.BAD_REQUEST)
public class AgeException extends RuntimeException {
}
```

测试一下：

```java
@RequestMapping(value = "/testGlobalException")
public String test02(){
    throw new AgeException();
}
```

我们还可以用 全局异常来接管自定义异常

```java
package com.llq.web.exception;

//  如果类上标注了 @ControllerAdvice，就是一个全局异常处理类
@ControllerAdvice
public class MyGlobalException {
    //	AgeException.class：接管自定义异常
    //	但是这样 e.getMessage 是空的，因为自定义异常中写的只会在默认页面展示，但是并没有传入到 message 里面去
    @ExceptionHandler({NumberFormatException.class, ClassCastException.class, AgeException.class})
    public String globalException(Exception e, HttpServletRequest request){
        System.out.println("全局异常处理~ " + e.getMessage());
        request.setAttribute("reason", e.getMessage());
        return "exception_mes";
    }
}
```

如果想要获得 message 信息的话，就重写 自定义异常的构造器

```java
@ResponseStatus(reason = " 年龄在 1- 120 之间", value = HttpStatus.BAD_REQUEST)
public class AgeException extends RuntimeException {
    public AgeException() {
    }

    public AgeException(String message) {
        super(message);
    }
}
```

#### SimpleMappingExceptionResolver（对所有异常统一处理）

基本说明：

1. 如果希望对所有异常进行统一处理，可以使用SimpleMappingExceptionResolver
2. 它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常
3. 需要在ioc 容器中配置

应用实例：

对数组越界进行统一处理，使用 SimpleMappingExceptionResolver

```java
@RequestMapping(value = "/testException03")
public String test03(){
    int[] arr = {3, 9, 10, 190};
    System.out.println(arr[90]);
    return "success";
}
```

```xml
<!-- 配置统一处理异常的 Bean -->
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
            <prop key="java.lang.ArrayIndexOutOfBoundsException">arrEx</prop>
        </props>
    </property>
</bean>
```

我们在这里 exceptionMappings 中定义一下当出现这个异常的时候，跳转到哪个页面，这里选择跳转到 arrEx.jsp 这个页面

需求：对未知异常统一处理

```java
@RequestMapping("testException04")
public String test04(){
    String str = "hello";
    char c = str.charAt(10);
    return "success";
}
```

```xml
<!-- 配置统一处理异常的 Bean -->
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
            <prop key="java.lang.ArrayIndexOutOfBoundsException">arrEx</prop>
            <prop key="java.lang.Exception">allEx</prop> <!-- 未知异常 -->
        </props>
    </property>
</bean>
```

#### 异常处理优先级梳理

局部异常> 全局异常> SimpleMappingExceptionResolver > tomcat 默认机制
