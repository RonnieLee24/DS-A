# 面试

## 1. Spring 生命周期

bean 对象创建是由JVM 完成的，然后执行如下方法

1. 执行构造器
2. 执行 set 相关方法
3. 调用bean 的初始化的方法（需要配置）
4. 使用bean
5. 当容器关闭时候，调用 bean 的销毁方法（需要配置）

后置处理器 会在 bean 初始化方法【init-method】 调用 前 和初始化方法调用 后 被调用

注意：即使没有 init() 方法，它也会执行！！!

## 2. init() 方法【实现 InitializingBean 接口】

```java
//	1. afterPropertiesSet 就是在 bean 的 setter 方法执行完毕后，被Spring 容器调用的
//	2. 即：初始化方法
public interface InitializingBean {
	void afterPropertiesSet() throws Exception;
}
```

多例下，每次 getBean（）都会拿到一个新的 Bean

所以：每次都会调用 初始化方法

## 3. 后置处理器 【实现 BeanPostProcessor 接口】

要使其成为真正的后置处理器，要在这2给方法中：

- postProcess<font color="yellow">**Before**</font>Initialization
- postProcess<font color="yellow">**After**</font>Initialization

### 判断 Class 对象是否实现了某个接口【接口.class.isAssignableFrom(aClass)】

- Class 文件不能用 instanceof 来判断是否实现了 BeanProcessor 接口
- 因为 Class 文件不是一个实例对象，而是一个类对象，使用 isAssignableFrom

```java
if (BeanPostProcessor.class.isAssignableFrom(aClass)){
    ArrayList.add((BeanPostProcessor) aClass.getConstructor().newInstance());
}
```

加入业务代码

```java
package com.llq.spring.processor;

/**
 *  1. 参考原生 Spring 容器，定义一个接口 BeanPostProcessor
 *  2. 该接口有 2个 方法
 *  3. 这 2个方法，会对 Spring 容器的所有 Bean 生效，已经是切面编程的概念了
 */

public interface BeanPostProcessor {
    
    //  在 Bean 的 init 方法前调用
    default Object postProcessBeforeInitialization(Object bean, String beanName){
        return bean;
    }

    // 在 Bean 的 init 方法后调用
    default Object postProcessAfterInitialization(Object bean, String beanName){
        return bean;
    }
}
```

## 4. AOP 机制【依赖于 Bean 后置处理器的 After 方法】

在后置处理器的 After 方法中，已经将 Bean 封装成 Proxy（代理对象）了

![image-20230518144952898](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305181449975.png)

相关配置整理：

| 注解方式                                                     | XML方式                                                      |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 开启 AOP 功能（使得 @Aspect 生效）                           | @EnableAspectJAutoProxy                                      | <aop:aspectj-autoproxy/>                                     |
| 切面类 **优先级 **指定                                       | @Order(value=n) 【n 越小，优先级越高】                       | <aop:aspect ref="smartAnimalAspect" order="1">               |
| **切入点表达式** 在前面类方法上增加注解@Pointcut 通过方法名复用 | @Pointcut(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))") // 定义一个切入点，在后面使用时可以直接引用，提高复用性 public void **myPointCut**(){} | <aop:pointcut id="myPoint" expression="execution(public int com.llq.spring.aop.homework1.MyCal.*(int))"/> |
| 横切关注点【1. 前置通知】                                    | @Before                                                      | <aop:before method="f1" pointcut-ref="myPoint"/>             |
| 横切关注点【2. 返回通知】                                    | @AfterReturning                                              | <aop:after-returning method="f2" pointcut-ref="myPoint"/>    |
| 横切关注点【3. 异常通知】                                    | @AfterThrowing                                               | <aop:after-throwing method="f3" pointcut-ref="myPointCut" throwing="e1"/> |
| 横切关注点【4. 最终通知】                                    | @After                                                       | <aop:after method="f4" pointcut-ref="myPointCut"/>           |
| 动态代理                                                     | **返回一个代理对象** Proxy.newProxyInstance( 类加载器、 真正要代理【执行】的对象的接口信息、 调用处理器 **InvocationHandler**) | 类加载器 bean.getClass().getClassLoader()  被代理对象的接口信息 bean.getClass().getInterfaces()  调用处理器：[传入一个 <font color="yellow">**匿名内部类**</font>] new InvocationHandler() 实现方法 |

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 使用 XML 配置，完成AOP 编程-->
    <!-- 1. 配置切面类 Bean-->
    <bean class="com.llq.spring.aop.xml.SmartAnimalAspect" id="smartAnimalAspect"/>

    <!-- 2. 配置目标类 Bean-->
    <bean class="com.llq.spring.aop.xml.Animal" id="animal"/>

    <!-- 3. 配置切面类关系 -->
    <aop:config>
        <!-- 配置切入点表达式 -->
        <aop:pointcut id="myPointCut" expression="execution(public double com.llq.spring.aop.xml.Animal.getSum(double, double))"/>
        <!-- 配置切面的前置，返回，异常，最终通知-->
        <aop:aspect ref="smartAnimalAspect" order="1">	<!-- 切面类 -->
            <!-- 配置前置通知 -->
            <aop:before method="f1" pointcut-ref="myPointCut"/>
            <!-- 配置返回通知-->
            <aop:after-returning method="f2" pointcut-ref="myPointCut" returning="res"/>
            <!-- 配置异常通知-->
            <aop:after-throwing method="f3" pointcut-ref="myPointCut" throwing="e1"/>
            <!-- 配置最终通知-->
            <aop:after method="f4" pointcut-ref="myPointCut"/>
        </aop:aspect>
    </aop:config>
</beans>
```

![image-20230518145310377](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305181453483.png)

![image-20230518145737576](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305181457745.png)

先死后活，后面我们可以通过 注解就可以更加灵活了！！

![221](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305181513165.png)

后置处理器代码如下：【在 After 方法中，根据需要看是返回原生 bean 对象，还是返回代理对象 proxy】

```java
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) {
    System.out.println("后置处理 LlqBeanPostProcessor 的 after 方法被调用，bean 类型：" + bean.getClass() + "bean的名字" + beanName);
    //  判断当前 Bean 是否需要返回 代理对象
    if ("animal".equals(beanName)){
        InvocationHandler invocationHandler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                System.out.println("method=" + method.getName());
                //  如果我们进行处理的方法是getSum() ===> 后面可以通过注解，做得更加灵活！！！
                if ("getSum".equals(method.getName())) {
                    SmartAnimalAspect.f1(); //  前置通知
                }
                Object result = method.invoke(bean, args);
                if ("getSum".equals(method.getName())) {
                    SmartAnimalAspect.f2(); //  后置通知
                }
                return result;
            }
        };
        ClassLoader classLoader = bean.getClass().getClassLoader();
        Class<?>[] interfaces = bean.getClass().getInterfaces();
        SmartAnimalable proxy = (SmartAnimalable)Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
        return proxy;
    }
    return bean;
}
```

## 5. 扫描路径 scanDir 与 反射 Path

自定义一个配置类【注解中包括：要扫描的包】

```java
package com.llq.spring.ioc;

import com.llq.spring.anntation.ComponentScan;

/**
 * 配置类，作用类似我们原生 Spring 的 beans.xml 容器配置文件
 */
@ComponentScan(value = "com.llq.spring.component")	//	扫描路径
public class LlqSpringConfig {
}
```

1. 通过获取配置类 @ComponentScan 注解的 value ===> com.llq.spring.component【<font color="red">**Path**</font>】

   ```bash
   # 初始 Path ===> 源自配置类的 @Component注解的 value
   com.llq.spring.component
   # 反射中的 classFullPath
   String classFullPath = com.llq.spring.component + 类名
   ```

2. 定义一个变量 String 【<font color="blue">**scanDir**</font>】 用来存储扫描路径

   ```bash
   # 初始 scanDir ===> com/llq/spring/component ===> 符合 IO 格式，用于查找目录下所有的 .class 文件
   String scanDir = path.replace(".", "/"); com/llq/spring/component
   # 得到扫描包下的所有资源(类.class) ===> 工作目录的 class
   URL resource = configClass.getClassLoader().getResource(scanDir);   # URL 对象有许多 API
   scanDir = resource.getPath();  # /D:/llq-myspring/target/classes/com/llq/spring/component
   ```

3. 查找文件夹下所有的 .class 文件

   ```java
   File file = new File(scanDir); //  得到目录
   File[] files = file.listFiles();    //  列出目录下的所有文件
   for (File f : files) {
       String absolutePath = f.getAbsolutePath();
       //  注意这里，只处理 .class 文件
       if (absolutePath.endsWith(".class")) {
   
           System.out.println(absolutePath);   //  D:\spring5\out\production\spring5\com\llq\spring\component\UserService.class
           //  现在反射需要得到：com.llq.spring.component.UserService
           //  1. 先获取类名
           String[] split = absolutePath.split("\\\\");
           String className = split[split.length - 1].split("\\.")[0];
           //  得到类名
           System.out.println("类名：" + className);
           //	得到反射路径
           String classFullName = path + "." + className; // 包名 + 类名
           System.out.println(classFullName);
           try {
               Class<?> aClass = Class.forName(classFullName);
               if (aClass.isAnnotationPresent(Component.class)) {
                   //  如果该类使用了 @Component 注解，说明是 Spring Bean
                   System.out.println("这是一个 Spring Bean= " + aClass);
               }else {
                   System.out.println("这不是一个 Spring Bean");
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

```java
package com.llq.spring.ioc;

/**
 * Spring 原生 Ioc 容器
 */
public class LlqSpringApplicationContext {
    private Class configClass;
    //  存放的是通过反射创建的对象（基于注解方式）
    private final ConcurrentHashMap<Object, Object> singleTonObject = new ConcurrentHashMap<>();

    public LlqSpringApplicationContext(Class configClass) {
        //  这里拿到了自定义配置类的 Class 类型
        this.configClass = configClass;
        System.out.println("配置类的 Class 类型");
        System.out.println("this.configClass= " + this.configClass);
        //  1. 先得到 LlqSpringConfig 配置的注解 @ComponentScan(value = "com.llq.spring.component")
        ComponentScan declaredAnnotation = (ComponentScan) this.configClass.getDeclaredAnnotation(ComponentScan.class);
        //  2. 通过 ComponentScan的 value ===> 要扫描的包
        String path = declaredAnnotation.value();
        System.out.println("待扫描的包如下：");
        System.out.println(path);   //  com.llq.spring.component ===> 路径的话，要将 . 替换为 、 ===》com/llq/spring/component
        String scanDir = path.replace(".", "/");
        System.out.println(path);

        //  3. 得到扫描包下的所有资源(类.class) ===> 工作目录的 class
        URL resource = configClass.getClassLoader().getResource(scanDir);  //  URL 对象有许多 API
        scanDir = resource.getPath();
        System.out.println("我们真正要扫描的路径如下：");
        System.out.println(scanDir);

        //  4. 将要加载的资源(.class) 路径下的文件进行遍历 ===> IO 知识

        File file = new File(scanDir); //  得到目录
        File[] files = file.listFiles();    //  列出目录下的所有文件
        for (File f : files) {
            String absolutePath = f.getAbsolutePath();
            //  注意这里，只处理 .class 文件
            if (absolutePath.endsWith(".class")) {

                System.out.println(absolutePath);   //  D:\spring5\out\production\spring5\com\llq\spring\component\UserService
                //  现在反射需要得到：com.llq.spring.component.UserService
                //  1. 先获取类名
                String[] split = absolutePath.split("\\\\");
                String className = split[split.length - 1].split("\\.")[0];
                //  得到类名
                System.out.println("类名：" + className);
                //  再将 / 改回成 .
                String classFullName = path + "." + className; // 包名 + 类名
                System.out.println(classFullName);

                //  2. 判断该类是否需要注入到容器中
                //      观察该类是否包含以下注解
                //      @Component、@Service、@Repository、@Controller
                try {
                    Class<?> aClass = Class.forName(classFullName);
                    if (aClass.isAnnotationPresent(Component.class)) {
                        //  如果该类使用了 @Component 注解，说明是 Spring Bean
                        System.out.println("这是一个 Spring Bean= " + aClass);
                    }else {
                        System.out.println("这不是一个 Spring Bean");
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
    //  编写方法，返回容器中对象
    public Object getBean(String name){
        return null;
    }
}
```



## 4. 接口编程

在创建好 Bean 实例后，判断是否要初始化，心得：

- 容器中常用的一个方法是：根据该类 **是否实现了某个接口**，来判断是否要执行某个业务逻辑
- 这里其实就是 java基础的 **接口编程** 实际运用

## 5. JDBC

### 1. preparedStatement（预处理）---> setString(index, string) 方法

PreparedStatement 执行的 SQL 语句中的参数用问好（?）来表示，调用 PreparedStatement 对象的 setXxx()方法 

【解决 sql 注入的关键】来设置这些参数，setXxx() 方法有 2 个参数：

```java
String sql = "SELECT COUNT(*) FROM admin WHERE username=? AND PASSWORD=?";
```

- 第一个：要设置的 SQL 语句中的参数的索引（从 1 开始）
- 第二个：设置的 SQL 语句中的参数的值

![image-20230519175316311](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191753393.png)

1. 调用 executeQuery()，返回 ResutlSet 对象

2. 调用 executeUpdate()：执行更新，包括：增、删、修改

   ![image-20230519175404275](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191754350.png)

   ![image-20230519175425763](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191754837.png)

预处理的好处：

1. 不再使用 + 拼接 sql 语句，减少语法错误
2. 有效地解决了 sql 注入问题i！
3. 大大减少了编译次数，效率较高

```java
/**
 * 演示 PreparedStatement 使用
 */
public class PreparedStatement_ {
    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {
        Scanner in = new Scanner(System.in);
        //  让用户输入管理员名和密码
        System.out.print("用户为：");
        String admin_name = in.nextLine();
        System.out.print("密码为：");
        String admin_pwd = in.nextLine();

        //  通过 properties 对象 获取配置文件的信息
        Properties properties = new Properties();
        properties.load(new FileInputStream("src/mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String url = properties.getProperty("url");
        String driver = properties.getProperty("driver");
        //  1. 注册驱动
        Class.forName(driver);
        //  2. 得到连接
        Connection connection = DriverManager.getConnection(url, user, password);
        //  3. 得到 preparedStatement
        //     组织 sql
        //  sql 语句的 ？相当于 占位符！！！
        String sql = "select name, pwd from admin where name= ? and pwd = ?";
        //  preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        //  给 ? 赋值【站位符 从 1 开始计算！！!】
        preparedStatement.setString(1, admin_name);
        preparedStatement.setString(2, admin_pwd);

        //  执行 select 语句使用 executeQuery
        //  如果执行的是 dml(update, insert, delete) 使用 executeUpdate()
        //  这里执行 executeQuery 时，不要再写 sql 了，因为前面已经绑定过了
        ResultSet resultSet = preparedStatement.executeQuery();
        //  5. 使用 while 取出数据
        if (resultSet.next()){
            System.out.println("HACK!!!!");
        }else {
            System.out.println("sorry!!!");
        }

        //  6. 关闭连接
        resultSet.close();
        preparedStatement.close();
        connection.close();
    }
}
```

预处理 DML：

添加用户：

```java
public class DML {
    public static void main(String[] args) throws IOException, SQLException, ClassNotFoundException {
        Scanner in = new Scanner(System.in);
        //  让用户输入管理员名和密码
        System.out.print("用户为：");
        String admin_name = in.nextLine();
        System.out.print("密码为：");
        String admin_pwd = in.nextLine();

        //  通过 properties 对象 获取配置文件的信息
        Properties properties = new Properties();
        properties.load(new FileInputStream("src/mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String url = properties.getProperty("url");
        String driver = properties.getProperty("driver");
        //  1. 注册驱动
        Class.forName(driver);
        //  2. 得到连接
        Connection connection = DriverManager.getConnection(url, user, password);
        //  3. 得到 preparedStatement
        //     添加 记录
        String sql = "insert into admin values(?, ?)";
        //  preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        //  给 ? 赋值【站位符 从 1 开始计算！！!】
        preparedStatement.setString(1, admin_name);
        preparedStatement.setString(2, admin_pwd);

        //  执行 dml 语句，使用 executeUpdate
        int rows = preparedStatement.executeUpdate();
        System.out.println(rows>0?"执行成功":"执行失败");
        //  6. 关闭连接
        preparedStatement.close();
        connection.close();
    }
}
```

修改用户

```java
//  3. 得到 preparedStatement
//     修改 记录
String sql = "update admin set pwd=? where name=?";
//  preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象
PreparedStatement preparedStatement = connection.prepareStatement(sql);
//  给 ? 赋值【站位符 从 1 开始计算！！!】
preparedStatement.setString(2, admin_name);
preparedStatement.setString(1, admin_pwd);	//	注意与 ？的对应关系！！！
```

删除用户

```java
//     删除 记录
String sql = "delete from admin where name=?";
//  preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象
PreparedStatement preparedStatement = connection.prepareStatement(sql);
//  给 ? 赋值【站位符 从 1 开始计算！！!】
preparedStatement.setString(1, admin_name);
```



### 2. 批处理（Batch）

1. 当需要成批插入或者更新记录时，可以采用 Java 的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率
2. JDBC 的批量处理语句包括如下方法：
   - addBatch()：添加需要批量处理的 SQL 语句或参数
   - executeBatch()：执行批量处理语句
   - clearBatch()：清空批处理包的语句
3. JDBC连接 MySQL时，如果要使用批处理功能，在 url 中添加参数 ?rewriteBatchedStatements=true
4. 批处理往往和 PreparedStatement一起搭配使用，可以既减少编译次数，又减少运行次数，提高效率

注意在 url 中添加语句

```xml
?rewriteBatchedStatements=true
```

```java
//  使用批量方式添加数据
@Test
public void useBatch() throws Exception {
    Connection connection = JDBCUtils.getConnection();
    String sql = "insert into admin2 values(null, ?, ?)";
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    System.out.println("开始执行");
    long start = System.currentTimeMillis();
    for (int i = 0; i < 5000; i++) {
        preparedStatement.setString(1, "jacck" + i);
        preparedStatement.setString(2, "666");
        //  将 sql 语句加入到 批处理包中 ---> 看源码
        preparedStatement.addBatch();
        //  每当有 1000 条记录时，再批量执行
        if ((i + 1) % 1000 == 0) {
            preparedStatement.executeBatch();
            //  清空一把
            preparedStatement.clearBatch();
        }
    }
    long end = System.currentTimeMillis();
    System.out.println("批量方式 耗时：" + (end - start));
    //  关闭连接
    JDBCUtils.close(null, preparedStatement, connection);
}
```

源码分析

```java
//  将 sql 语句加入到 批处理包中 ---> 看源码
preparedStatement.addBatch();
```

下断点执行：

```java
public void addBatch() throws SQLException {
    synchronized(this.checkClosed().getConnectionMutex()) {
        if (this.batchedArgs == null) {
   	// 1. 第一次就创建 ArrayList --- elementData => Object[] 
    // 2. 就会存放我们预处理的 sql 语句
    // 3. 当 elementData 满后，就按照 1.5 倍扩容
    // 4. 当添加到指定值后，就 executeBatch
    // 5. 批量处理会减少我们发送 sql语句的网络开销，而且减少编译次数，因此提升效率！！！
            this.batchedArgs = new ArrayList();
        }

        for(int i = 0; i < this.parameterValues.length; ++i) {
            this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);
        }

        this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));
    }
}
```

![image-20230519111344736](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191113814.png)

### 3. 连接池【实现 DataSource 接口的第三方工具类】close 不是真正关闭连接，而是把连接放入到连接池中

问题分析：

1. 传统的 JDBC 数据库连接使用 DriverManager 来获取
   - 每次向数据库建立连接的时候都将 Connection 加载到内存中
   - 再验证 IP 地址，用户名 和 密码【0.05s ~ 1s 时间】。
   - 需要数据库连接的时候，就向数据库要求一个
   - 频繁进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃
2. 每一次数据库连接，使用完后逗得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。
3. 传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，Mysql 崩溃
4. 解决传统开发中的 数据库连接问题，可以采用数据库连接池技术（connectino pool）

给张三打电话，打完了，说：不要挂电话，你让李四接电话！！！

可以理解成电话一直都没挂断

春节售票窗口 ---> 等待队列

![image-20230519111501576](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191115642.png)

数据库连接池种类

1. JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个 接口，该接口由第三方提供实现【提供 .jar包】
2. CP30 数据库连接池，速度相对较慢，稳定性不错（hihernate, spring）
3. DBCP数据库连接池，速度相对 cp30 较快，但不稳定
4. Proxool 数据库连接池，有监控连接池状态的功能，稳定性较 c3p0 差一点
5. BoneCP 数据库连接池，速度快
6. Druid（德鲁伊）是阿里提供的数据库连接池，集 DBCP，C3P0，Proxool，优点于一身的数据库连接池

![image-20230519111616913](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191116993.png)

Druid 工具类

```java
/**
 * 基于 Druid 数据库连接池的工具类
 */
public class JDBCUtilsByDruid {
    private static DataSource ds;

    //  在静态代码块中完成 ds 初始化
    static {
        //  1. 加入 Druid jar 包
        //  2. 加入 配置文件，将该文件拷贝到项目的 src 目录
        //  3. 创建 Properties 对象，读取配置文件
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream("src/druid.properties"));
        // 4. 创建一个指定参数的数据库连接池，Druid 连接池
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //  编写 getConnection 方法
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    //  关闭连接，强调：在数据库连接池技术中，close 不是真正的断掉链接
    //  而是把使用的 Connection 对象放回连接池
    public static void close(ResultSet resultSet, Statement statement, Connection connection){
        try {
            if (resultSet != null){
                resultSet.close();
            }
            if (statement != null){
                statement.close();
            }
            if (connection != null){
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
```

测试：

```java
public void testDML(){  //  insert、update、delete
    System.out.println("使用德鲁伊方式完成！！！");
    //  1. 得到连接
    Connection connection = null;
    //  2. 组织一个 sql
    String sql = "update actor set name = ? where id = ?";
    //  3. 创建 PreparedStatement 对象
    PreparedStatement preparedStatement = null; //  扩大作用域！！！
    try {
        connection = JDBCUtilsByDruid.getConnection();
        System.out.println(connection.getClass() );
        preparedStatement = connection.prepareStatement(sql);
        //  给占位符赋值
        preparedStatement.setString(1, "周星驰");
        preparedStatement.setInt(2, 4);
        //  执行
        preparedStatement.executeUpdate();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        //  关闭资源
        JDBCUtilsByDruid.close(null, preparedStatement, connection);
    }
}
```

### 4. Apache-DBUtils【保存 resultSet 结果集】

基本介绍

1. commons-dbutils 是 Apache 组织提供的一个开源 JDBC 工具类库，它是堆 JDBC 的封装，使用 dbutils 能极大简化 jdbc 编码的工作量
2. <font color="yellow">**QueryRunner**</font> 类：封装 SQL 执行，线程安全，可以实现增、删、改、查、批处理
3. 使用 QueryRunner 类 <font color="yellow">实现查询</font>
4. <font color="yellow">**ResultSetHandler**</font> 接口：该接口用于处理 java.sql.ResultSet，<font color="yellow">将数据按照要求转换</font> 为另一种形式

| Handler            | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| ArrayHandler       | 把结果集中的第一行数据转成对象数组                           |
| ArrayListHandler   | 把结果集中的每一行数据都转成一个数组，再存放到List中         |
| BeanHandler        | 将结果集中的第一行数据封装到一个对应的JavaBean实例中         |
| BeanListHandler    | 将结果集中的 每一行数据 都封装到一个对应的JavaBean实例中，存放到List里 |
| ColumnListHandler  | 将结果集中某一列的数据存放到List中                           |
| KeyedHandler(name) | 将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key |
| MapHandler         | 将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值 |
| MapListHandler     | 将结果集中的每一行数据都封装到一个Map里，然后再存放到List    |

应用实例：

使用 APACHE-DBUtils + 数据连接池（德鲁伊）方式，完成对表 actor 的 CRUD

```java
//  使用 APACHE-DBUtils 工具类 + druid 完成对表的 CRUD操作
@Test
public void testQueryMany() throws SQLException {    //  返回结果是多行的情况
    //  1. 得到连接（druid）
    Connection connection = JDBCUtilsByDruid.getConnection();
    //  2. 使用 DBUtils 类和接口，先引入 DBUtils 相关 jar
    //  3. 创建 QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    //  4. 就可以执行相关的方法，返回 ArrayList 结果集
    String sql = "select * from actor where id >=?";
    //  解读：
    //  1) query 方法就是执行 sql 语句，得到 resultSet --封装到--> ArrayList 集合中
    //  2) 然后返回集合
    //  3) connection；连接
    //  4) sql：执行的 sql 语句
    //  5) new BeanListHandler<>(Actor.class)：将 resultSet ---> Actor 对象 ---> 封装到 ArrayList
    //  底层使用：反射机制 去获取 Actor 类的属性，然后进行封装
    //  6）1：就是给sql 语句中的 ? 赋值，可以有多个值，因为是可变参数
    // public <T> T query(Connection conn, String sql, ResultSetHandler<T> rsh, Object... params)
    //  7）底层得到的 resultSet，会在 query方法中 关闭，还会关闭 preparedStatement
    List<Actor> list = queryRunner.query(connection, sql, new BeanListHandler<>(Actor.class), 1);
    System.out.println("输出集合的信息");
    for (Actor actor : list) {
        System.out.println(actor);
    }
    //  释放资源

    JDBCUtilsByDruid.close(null, null, connection);
}
```

源码分析（反射）

```java
List<Actor> list = queryRunner.query(connection, sql, new BeanListHandler<>(Actor.class), 1);
```

```java
public <T> T query(Connection conn, String sql, ResultSetHandler<T> rsh, Object... params) throws SQLException {
    PreparedStatement stmt = null;
    ResultSet rs = null;
    Object result = null;

    try {
        stmt = this.prepareStatement(conn, sql);
        this.fillStatement(stmt, params);	//	给 ? 赋值
        rs = this.wrap(stmt.executeQuery());	//	执行 sql 语句，将结果封装
        result = rsh.handle(rs); //	返回的 resultSet ---> arrayList 应用反射（对传入的 class 对象处理）
    } catch (SQLException var33) {
        this.rethrow(var33, sql, params);
    } finally {
        try {
            this.close(rs);	//	关闭 resultSet
        } finally {
            this.close((Statement)stmt);	//	关闭 preparedStatement 对象
        }
    }
    return result;	//	最后返回结果集
}
```

单行记录

```java
@Test
//  演示 apache-dbUtils + druid 完成 返回的结果是单行记录（单个对象）
public void testQuerySingle() throws SQLException {
    //  1. 得到连接（druid）
    Connection connection = JDBCUtilsByDruid.getConnection();
    //  2. 使用 DBUtils 类和接口，先引入 DBUtils 相关 jar
    //  3. 创建 QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    //  4. 就可以执行相关的方法，返回 单个对象
    String sql = "select * from actor where id = ?";
    //  因为我们返回的单行记录 <---> 单个对象，使用的  Handler 是 BeanHandler
    Actor actor = queryRunner.query(connection, sql, new BeanHandler<>(Actor.class), 4);
    System.out.println(actor);
    //  释放连接
    JDBCUtilsByDruid.close(null, null, connection);
}
```

单行单列【返回的就是对象】

Scalar：标量（单一）

```java
@Test
//  查询结果是单行单列：返回的就是 object
public void testScalar() throws SQLException {
    //  1. 得到连接（druid）
    Connection connection = JDBCUtilsByDruid.getConnection();
    //  2. 使用 DBUtils 类和接口，先引入 DBUtils 相关 jar
    //  3. 创建 QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    //  4. 就可以执行相关的方法，返回 单行单列，返回的就是 Object
    String sql = "select name from actor where id = ?";
    // 解读：因为返回的是一个对象，使用的 handler 就是 ScalarHandler

    Object obj = queryRunner.query(connection, sql, new ScalarHandler(), 4);
    System.out.println(obj);
    //  释放连接
    JDBCUtilsByDruid.close(null, null, connection);
}
```

DML 操作

```java
@Test
public void testDML() throws SQLException {
    //  1. 得到连接（druid）
    Connection connection = JDBCUtilsByDruid.getConnection();
    //  2. 使用 DBUtils 类和接口，先引入 DBUtils 相关 jar
    //  3. 创建 QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    //  4. 组织 sql 完成 update、insert、delete
    String sql = "update actor set name  = ? where id = ?";
    // 解读：
    //  1. 执行 DML 操作，queryRunner.update()
    //  2. 返回的值是受影响的行数
    int affectedRow = queryRunner.update(connection, sql, "张三丰", 4);
    System.out.println(affectedRow > 0 ? "执行成功":"没有影响");
    //  释放连接
    JDBCUtilsByDruid.close(null, null, connection);
}
```

### 5. DAO 增删改查 - BasicDAO

apache-dbutils + Druid 简化了 JDBC 开发，但还有不足：

1. SQL 语句是固定的，不能通过 参数传入，通用性不好，需要进行改进，更方便执行 CRUD
2. 对于 select 操作，如果有返回值，返回类型不能固定，需要使用 **泛型**
3. 将来的表很多，业务需求复杂，不能只靠一个 Java 类完成
4. 引出 ===> BasicDAO 画出示意图

![image-20230519113837771](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191138845.png)

基本说明

1. DAO：data access object 数据访问对象
2. 这样的通用类，称为 BasicDao，是专门与数据库交互的，即完成对数据库（表）的 crud 操作
3. 在 BasicDao 基础上，实现一张表 对应一个 Dao，更好地完成功能，比如：Cunstomer表 --> Customer.java类(javabean)-->CustomerDao.java

应用实例

完成一个简单的设计

com.llq.dao_

- utils：工具类
- domain：javabean
- dao：存放XxxDAO 和 BasicDAO
- test：写测试类

![nnjq](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191210226.png)

![image-20230519121145049](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191211141.png)

## 6. JDBC Template

实际需求: 如果程序员就希望使用spring 框架来做项目，spring 框架如何处理对数据库的操作呢?

- 方案1. 使用前面做项目开发的JdbcUtils 类
- 方案2. 其实 spring 提供 了一个操作数据库(表)功能强大的类 **JdbcTemplate** 。我们可以同 ioc 容器来配置一个jdbcTemplate 对象，使用它来完成对数据库表的各种操作.

我们使用 spring 的方式来完成JdbcTemplate 配置和使用

导入 jar 包

![image-20230519093412256](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190934348.png)

![image-20230519093444824](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190934908.png)

![image-20230519093326943](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190933061.png)

### 创建配置文件 src/JdbcTemplate_ioc.xml【Spring 配置】

数据源【数据库连接池】

![image-20230519093649188](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190936268.png)

![image-20230519093927039](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190939178.png)

驱动

![image-20230519093741980](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190937066.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 引入外部的 JDBC.properties文件 -->
    <context:property-placeholder location="classpath:JDBC.properties"/>

    <!--JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个 接口，该接口由第三方提供实现【提供 .jar包】
        1. CP30
        2. DBCP数据库连接池
        3. Proxool
        4. BoneCP
        5. Druid：阿里提供的数据库连接池，集 DBCP，C3P0，Proxool，优点于一身的数据库连接池
    -->
    <!-- 配置数据源对象==DataSource== -->
    <bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="dataSource">
        <!--给数据源对象，配置属性值-->
        <property name="user" value="${jdbc.userName}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="driverClass" value="${jdbc.driver}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
    </bean>
</beans>
```

![image-20230519094206429](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190942535.png)

测试

```java
package com.llq.spring.test;

public class JDBCTemplateTest {
    @Test
    public void testJDBCTemplate(){
        ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
        ComboPooledDataSource dataSource = ioc.getBean("dataSource", ComboPooledDataSource.class);
        try {
            Connection connection = dataSource.getConnection();
            System.out.println(connection);
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

数据源的连接：其实是一个 **代理连接对象**，是通过数据连接池返回的连接

![image-20230519094505957](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190945073.png)

### 添加数据

1. 配置 JdbcTemplate 对象
2. 给 JdbcTemplate 对象配置 dataSource 属性

```xml
<!-- 配置 JdbcTemplate 对象 -->
<bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate">
    <!-- 给 JdbcTemplate 对象配置 dataSource 属性-->
    <property name="dataSource" value="dataSource"/>
</bean>
```

![image-20230519094918610](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190949743.png)

![image-20230519094942727](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305190949813.png)

```java
//	1. execute
String sql = "Insert into monster values(400, '小龙女', '枪法')";
jdbcTemplate.execute(sql);
//	2. update
String sql1 = "Insert into monster values(?, ?, ?)";
//  执行后，表受影响的记录数
int affectedRows = jdbcTemplate.update(sql1, 500, "关羽", "大鹏展翅");
System.out.println(affectedRows);
```

### 修改数据

```java
@Test
public void updateDataByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);

    String sql = "update monster set skill=? where id=?";
    int affectedRows = jdbcTemplate.update(sql, "无影刀", 400);
    System.out.println(affectedRows);
}
```

### 批量处理 batchUpdate(String sql, List<Object[]> batchArgs)

```java
//  批量添加 3 个 monster 张飞、飞天德、哪吒
//  这里有一个使用 API 技巧
//      1. 确定 API名字
//      2. 根据 API 提供相应的参数【组织参数】
//      3. 将自己的调用思路清晰
//  batchUpdate(String sql, List<Object[]> batchArgs)
@Test
public void BatchUpdateByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    List<Object[]> batchArgs = new ArrayList<>();

    Object[] objects = new Object[]{600, "张飞", "蛮牛式"};
    String[] strings = new String[]{"1", "22"};

    String sql = "Insert into monster values(?, ?, ?)";
    batchArgs.add(new Object[]{600, "张飞", "蛮牛式"});
    batchArgs.add(new Object[]{700, "飞天德", "飞天"});
    batchArgs.add(new Object[]{800, "哪吒", "三味真火"});

    int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
    for (int anInt : ints) {
        System.out.println("anInt= " + anInt);
    }
}
```

### 查询后封装成对象【jdbcTemplate.queryForObject(sql, rowMapper)】

```java
//  查询 id = 100 的 monster，并封装成 Monster 对象【实际开发中，非常有用！！！】
@Test
public void selectDataByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    //  组织 sql
    String sql = "select id monsterId, `name`, skill from monster where id = 100";
    //  通过 BeanPropertyRowMapper 读取， rowMapper 是一个接口，可以将查询的结果，封装到你指定的 Monster 对象中
    //  使用 RowMapper 接口来对返回的数据，进行一个封装 ===> 底层使用的是 反射 ===> setter 方法
    //  这里有一个细节：你查询的记录的表的字段需要和 Monster对象字段名保持一致【通过 mysql 重命名表头 as】
    RowMapper<Monster> rowMapper = new BeanPropertyRowMapper<>(Monster.class);  //  反射的时候，需要 class 对象

    // public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)

    Monster monster = jdbcTemplate.queryForObject(sql, rowMapper);
    System.out.println("monster= " + monster);
}
```

查询 id > 200 的 monster，并封装成 Monster 对象

```java
@Test
public void selectMultiDataByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    //  组织 sql
    String sql = "select id monsterId, `name`, skill from monster where id >= ?";

    RowMapper<Monster> rowMapper = new BeanPropertyRowMapper<>(Monster.class);  //  反射的时候，需要 class 对象
    List<Monster> monsters = jdbcTemplate.query(sql, rowMapper, 200);
    for (Monster monster : monsters) {
        System.out.println("monster= " + monster);
    }
}
```

### 返回单行单列

```java
@Test
public void selectScalaByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    JdbcTemplate jdbcTemplate = ioc.getBean("jdbcTemplate", JdbcTemplate.class);
    //  确定 API
    //  public <T> T queryForObject(String sql, Class<T> requiredType)

    //  组织 sql
    String sql = "select `name` from monster where id = ?";

    String s = jdbcTemplate.queryForObject(sql, String.class, 500);

    System.out.println("id = 500 的名字是：" + s);
}
```

### 使用 Map传入具名参数完成操作【namedParameterJdbcTemplate.update(sql, map);】

```xml
<!-- 配置 NamedParameterJdbcTemplate 对象-->
<bean class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate" id="namedParameterJdbcTemplate">
    <!-- 通过构造器，设置数据源-->
    <constructor-arg name="dataSource" ref="dataSource"/>
</bean>
```

```java
@Test
public void testDataByNameParameterByJdbcTemplate(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    NamedParameterJdbcTemplate namedParameterJdbcTemplate = ioc.getBean("namedParameterJdbcTemplate", NamedParameterJdbcTemplate.class);

    //  确定 API
    // public int update(String sql, Map<String, ?> paramMap) throws DataAccessException {

    //  组织 sql
    String sql = "Insert into monster values(:id, :name, :skill)";
    //  准备参数 [:my_id, :name, :skill] 要求按照规定的的名字来设置参数
    Map<String, Object> map = new HashMap<>();
    map.put("id", 900);
    map.put("name", "蚂蚁精");
    map.put("skill", "挖洞");
    int affectedRows = namedParameterJdbcTemplate.update(sql, map);
    System.out.println(affectedRows);
}
```

### 使用 sqlparametersource 来封装具名参数

```java
@Test
public void operDataBySqlparametersource(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    NamedParameterJdbcTemplate namedParameterJdbcTemplate = ioc.getBean("namedParameterJdbcTemplate", NamedParameterJdbcTemplate.class);
    //  1. 确定 API
    // public int update(String sql, SqlParameterSource paramSource)
    // public BeanPropertySqlParameterSource(Object object)
    Monster monster = new Monster(1000, "虹猫", "长虹剑");   //  现在是以对象传进去的！！！
    SqlParameterSource sqlParameterSource = new BeanPropertySqlParameterSource(monster);
    //  2. 准备参数
    String sql = "Insert into monster values(:monsterId, :name, :skill)";

    //  3. 调用
    int affectedRows = namedParameterJdbcTemplate.update(sql, sqlParameterSource);
    System.out.println(affectedRows);
}
```

### DAO 使用 jdbctemplate

```java
package com.llq.spring.jdbctemplate.dao;

@Repository //  将 MonsterDao 注入到 Spring 容器
public class MonsterDao {
    //  注入一个属性
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //  完成保存任务
    public void save(Monster monster){
        //  组织 sql 语句
        String sql = "Insert into monster values(?, ?, ?)";
        int affectedRows = jdbcTemplate.update(sql, monster.getMonsterId(), monster.getName(), monster.getSkill());
        System.out.println("affectedRows= " + affectedRows);
    }
}
```

测试：

```java
@Test
public void testDaoSave(){
    ApplicationContext ioc = new ClassPathXmlApplicationContext("JdbcTemplate_ioc.xml");
    MonsterDao monsterDao = ioc.getBean("monsterDao", MonsterDao.class);
    monsterDao.save(new Monster(1001, "蓝兔", "冰魄剑"));
}
```

## 7. 声明式事务【@Transactional】

### 事务分类

#### 编程式事务

示意代码, 传统方式

```java
Connection connection = JdbcUtils.getConnection();
try {
    //1. 先设置事务不要自动提交
    connection.setAutoCommint(false);
    //2. 进行各种crud
    //多个表的修改，添加，删除
    //3. 提交
    connection.commit();
} catch (Exception e) {
    //4. 回滚
    conection.rollback();
}
```

#### 声明式事务【切面类DataSourceTransactionManager（指定数据源）切入到 @Transactional 方法】

需求说明-用户购买商品

我们需要去处理用户购买商品的业务逻辑:分析: 当一个用户要去购买商品应该包含三个步骤

1. 通过商品id 获取价格
2. 购买商品(某人购买商品，修改用户的余额.)
3. 修改库存量

其实大家可以看到，这时，我们需要涉及到三张表商品表，用户表，商品存量表。应该使用事务处理

解决方案分析：

1. 使用传统的编程事务来处理，将代码写到一起【缺点: 代码冗余，效率低，不利于扩展, 优点是简单，好理解】

   ```java
   Connection connection = JdbcUtils.getConnection();
   try {
       // 1. 先设置事务不要自动提交
       connection.setAutoCommit(false);
       // 2. 进行各种crud
       // 多个表的修改，添加，删除
       select from 商品表=> 获取价格
           修改用户余额update ...
           修改库存量update
       // 3. 提交
       connection.commit();
   } catch (Exception e) {
       // 4. 回滚
       conection.rollback();
   }
   ```

2. 使用Spring 的声明式事务处理， 可以将上面三个子步骤分别写成一个方法，然后统一管理

   - 这个是Spring 很牛的地方，在开发使用的很多，优点是无代码冗余，效率高，扩展方便，缺点是理解较困难]
   - 底层使用AOP (动态代理+动态绑定+反射+注解) => 看Debug 源码.

声明式事务 --- 代码实现

创建 GoodsDao.java文件

```java
package com.llq.spring.tx.dao;

@Repository
public class GoodsDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    //  根据商品 id, 返回价格
    public Float queryPriceById(Integer id) {
        String sql = "SELECT price From goods Where goods_id=?";
        Float price = jdbcTemplate.queryForObject(sql, Float.class, id);
        return price;
    }

    //  修改用户余额
    public void updateBalance(Integer user_id, Float money) {
        String sql = "UPDATE user_account SET money=money-? Where user_id=?";
        jdbcTemplate.update(sql, money, user_id);
    }

    //  修改商品库存
    public void updateAmount(Integer goods_id, int amount){
        String sql = "UPDATE goods_amount SET goods_num=goods_num-? Where goods_id=?";
        jdbcTemplate.update(sql, amount , goods_id);
    }
}
```

编写GoodsService.java，编写方法，验证不使用事务就会出现数据不一致现象

```java
package com.llq.spring.tx.service;

@Service
public class GoodsService {
    @Autowired
    private GoodsDao goodsDao;

    //  编写一个方法完成用户购买商品业务
    public void buyGoods(int userId, int goodsId, int amount){
        System.out.println("用户购买信息 userId= " + userId + "goodsId= " + goodsId + "amount= " + amount);
        Float price = goodsDao.queryPriceById(goodsId);    //  价格
        goodsDao.updateBalance(userId, price * amount);    //  减少用户余额 【先付款，后减少库存量】

        goodsDao.updateAmount(goodsId, amount); //  减少库存量
    }
}
```

编写一个方法完成用户购买商品业务

```java
//  编写一个方法完成用户购买商品业务
//  1. 使用 Transactional 可以进行声明式事务控制
//  2. 即将标识的方法中的，对数据库的操作作为一个事务管理
@Transactional
public void buyGoodsByTx(int userId, int goodsId, int amount){
    System.out.println("用户购买信息 userId= " + userId + "goodsId= " + goodsId + "amount= " + amount);
    Float price = goodsDao.queryPriceById(goodsId);    //  价格
    goodsDao.updateBalance(userId, price * amount);    //  减少用户余额 【先付款，后减少库存量】
    goodsDao.updateAmount(goodsId, amount); //  减少库存量
}
```

```xml
<!-- 配置事务管理器=== 对象
    1. DataSourceTransactionManager 这个对象是进行事务管理 === debug源码
    2. 一定要配置数据源属性，这样就指定该事务管理器是对哪个数据源进行事务控制
 -->
<bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="dataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 配置基于注解的声明式事务管理功能 -->
<tx:annotation-driven transaction-manager="dataSourceTransactionManager"/>
```

声明式事务机制 - Debug

底层使用 **动态代理对象** 来调用 buyGoodsByTx

- 先调用 事务管理器的 doBegin()
- 调用 buyGoodsByTx()
  - 如果执行无异常，则调用 事务管理器 doCommit() 方法
  - 如果发生异常，就会调用事务管理器 doRollbask() 方法

![image-20230519123602528](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191236658.png)

![image-20230519123711552](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191237652.png)

### 事务传播机制【propagation：传播】

事务的传播机制

1. 当有多个事务处理并存时，如何控制?
2. 比如用户去购买两次商品(使用不同的方法), 每个方法都是一个事务，那么如何控制呢?
3. 这个就是事务的传播机制，看一个具体的案例(如图)

![image-20230519151240117](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191512226.png)

事务传播的属性/种类一览图

| 传播属性           | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| REQUIRED（默认的） | 如果有事务在运行，当前的方法就在这个事务内运行 否则，就启动一个新的事务，并在自己的事务内运行 |
| REQUIRES_NEW       | 当前的方法必须启动新事务，并在它自己的事务内运行．如果有事务正在运行，应该将它挂起 |
| SUPPORTS           | 如果有事务在运行，当前的方法就在这个事务内运行.否则它可以不运行在事务中. |
| NOT_SUPPORTE       | 当前的方法不应该运行在事务中．如果有运行的事务，将它挂起     |
| MANDATORY          | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
| NEVER              | 当前的方法不应该运行在事务中．如果有运行的事务，就抛出异常   |
| NESTED             | 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行。否则，就启动一个新的事务，并在它自己的事务内运行. |

事务传播的属性/种类机制分析，重点分析了 REQUIRED 和 REQUIRES_NEW 两种事务传播属性, 其它知道即可(看上图)

![image-20230519151457069](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191514155.png)

![image-20230519151651723](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191516818.png)

### 事务传播机制的设置方法

![image-20230519151747908](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191517432.png)

```java
@Transactional(propagation = Propagation.REQUIRED)

@Transactional(propagation = Propagation.REQUIRES_NEW)
```

### REQUIRES_NEW 和REQUIRED 【默认】在处理事务的策略

![image-20230519152130161](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191521272.png)

1. 如果设置为REQUIRES_NEW
   - buyGoods2 如果错误，不会影响到buyGoods()反之亦然，即它们的事务是独立的.
2. 如果设置为REQUIRED
   - buyGoods2 和buyGoods 是一个整体，只要有方法的事务错误，那么两个方法都不会执行成功!

应用实例：

比如用户去购买两次商品(使用不同的方法), 每个方法都是一个事务，那么如何控制呢? =>这个就是事务的传播机制

```java
package com.llq.spring.tx.service;

@Service
public class MultiplyService {
    @Autowired
    private GoodsService goodsService;
    //  解读：
    //  1. multiBuyGoodsByTx 这个方法，有2次 购买商品操作
    //  2. buyGoodsByTx 和 buyGoodsByTx2 都是声明式事务
    //  3. 当前 buyGoodsByTx 和 buyGoodsByTx2 使用的传播属性是默认的，即：@Transactional(propagation = Propagation.REQUIRED)
    //  即会当做一个整体事务进行管理
    //  比如：buyGoodsByTx 方法成功，但是buyGoodsByTx2 失败
    //  会造成整个事务的回滚，即：会回滚 multiBuyGoodsByTx
    @Transactional
    public void multiBuyGoodsByTx(){
        goodsService.buyGoodsByTx(1, 1, 1);
        goodsService.buyGoodsByTx2(1, 1, 1);
    }
}
```

### 事务的隔离级别

事务隔离级别的概念在mysql 讲过, 就不再说了, 在Mysql 的799 讲

- 脏读：别人没提交的，你也可以看到
- 不可重复读：修改或者删除
- 幻读：插入

![image-20230519152709157](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191527260.png)

1. 默认的隔离级别, 就是mysql 数据库默认的隔离级别一般为REPEATABLE_READ
2. 看源码可知Isolation.DEFAULT 是：Use the default isolation level of the underlying datastore

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    @AliasFor("transactionManager")
    String value() default "";

    @AliasFor("value")
    String transactionManager() default "";

    String[] label() default {};

    Propagation propagation() default Propagation.REQUIRED;

    Isolation isolation() default Isolation.DEFAULT;	//	默认的隔离级别！！！

    int timeout() default -1;

    String timeoutString() default "";

    boolean readOnly() default false;

    Class<? extends Throwable>[] rollbackFor() default {};

    String[] rollbackForClassName() default {};

    Class<? extends Throwable>[] noRollbackFor() default {};

    String[] noRollbackForClassName() default {};
}
```

```java
//	枚举类型 isolation
public enum Isolation {

	DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),

	READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),

	READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),

	REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),

	SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);


	private final int value;


	Isolation(int value) {
		this.value = value;
	}

	public int value() {
		return this.value;
	}

}
```

```java
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface TransactionDefinition {

	int PROPAGATION_REQUIRED = 0;

	int PROPAGATION_SUPPORTS = 1;

	int PROPAGATION_MANDATORY = 2;

	int PROPAGATION_REQUIRES_NEW = 3;

	int PROPAGATION_NOT_SUPPORTED = 4;

	int PROPAGATION_NEVER = 5;

	int PROPAGATION_NESTED = 6;

	int ISOLATION_DEFAULT = -1;

	int ISOLATION_READ_UNCOMMITTED = 1;  // same as java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;

	int ISOLATION_READ_COMMITTED = 2;  // same as java.sql.Connection.TRANSACTION_READ_COMMITTED;

	int ISOLATION_REPEATABLE_READ = 4;  // same as java.sql.Connection.TRANSACTION_REPEATABLE_READ;

	int ISOLATION_SERIALIZABLE = 8;  // same as java.sql.Connection.TRANSACTION_SERIALIZABLE;

	int TIMEOUT_DEFAULT = -1;

	default int getPropagationBehavior() {
		return PROPAGATION_REQUIRED;
	}

	default int getIsolationLevel() {
		return ISOLATION_DEFAULT;
	}

	default int getTimeout() {
		return TIMEOUT_DEFAULT;
	}

	default boolean isReadOnly() {
		return false;
	}

	@Nullable
	default String getName() {
		return null;
	}

	static TransactionDefinition withDefaults() {
		return StaticTransactionDefinition.INSTANCE;
	}

}
```

查看数据库隔离级别【默认是：可重复读】

```bash
select @@global.tx_isolation
```

![image-20230519152934426](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191529508.png)

### 事务隔离级别的设置和测试

1. 修改 GoodsService.java，先测默认隔离级别，增加方法 buyGoodsByTxISOLATION()

   ![image-20230519153300842](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191533941.png)

2. 修改声明式事务隔离级别

   ![image-20230519153327056](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191533148.png)

### 事务超时回滚

1. 如果一个事务执行的时间超过某个时间限制，就让该事务回滚
2. 可以通过设置事务超时回顾来实现

基本语法：

![image-20230519153647914](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202305191536007.png)

```java
//  测试事务的超时回滚(超时时间，我们设置为 2 秒，该事务就进行回滚
//  如果没有设置 timeout 属性，默认是 -1，表示使用事务的默认超时时间
//  或者不支持
@Transactional(timeout = 2)
public void buyGoodsByTxTimeout(int user_id, int goods_id, int num) {
    //查询到商品价格
    Float goods_price = goodsDao.queryPriceById(goods_id);
    //购买商品，减去余额
    goodsDao.updateBalance(user_id, goods_price * num);
    System.out.println("====超时start====");
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("====超时end====");
    //更新库存
    goodsDao.updateAmount(goods_id, num);
}
```

